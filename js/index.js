// Generated by CoffeeScript 2.3.1
var changeCond2, checkMimic, clear, compareIndexes, cond2cond1, debug, genPattern, getCellNum, getColorIndexes, getColorNearIndexes, getLineIndexes, getNearIndexes, getNumCommodity, getNumEquip, getNumMimic, getNumMoney, getTd, getValidPattern, getX, getY, init, isContainType, isContainTypeCount, isMimicNearly, isNotContainType, isValidPattern, judge, mustConsiderType, reset, viewTitle;

window.CONFIG = {
  FIELD_MIN: 2,
  FIELD_MAX: 8
};

window.CONSTS = {
  NOT_MIMIC: 0,
  MIMIC: 1,
  EQUIP: 2,
  MONEY: 3,
  COMMODITY: 4
};

window.COLORS = {
  RED: 1,
  BLUE: 2,
  BLACK: 3
};

window.DIRECTIONS = {
  UP: 1,
  DOWN: 2,
  LEFT: 3,
  RIGHT: 4
};

window.CONDS = {
  'Zzz...': {
    0: 'Zzz...'
  },
  'ミミック同士は縦か横で隣あった位置に': {
    1100: 'いる',
    1110: 'いない'
  },
  '上の宝箱は': {
    710: 'ミミックだ',
    720: 'ミミックじゃない'
  },
  '下の宝箱は': {
    810: 'ミミックだ',
    820: 'ミミックじゃない'
  },
  '左の宝箱は': {
    910: 'ミミックだ',
    920: 'ミミックじゃない'
  },
  '右の宝箱は': {
    1010: 'ミミックだ',
    1020: 'ミミックじゃない'
  },
  '赤い宝箱の中に': {
    10: 'ミミックがいるよ',
    20: 'ミミックはいないよ',
    30: 'ミミックは0匹いる',
    31: 'ミミックは1匹いる',
    32: 'ミミックは2匹いる',
    33: 'ミミックは3匹いる',
    34: 'ミミックは4匹いる',
    35: 'ミミックは5匹いる',
    36: 'ミミックは6匹いる',
    37: 'ミミックは7匹いる',
    38: 'ミミックは8匹いる',
    39: 'ミミックは9匹いる'
  },
  '青い宝箱の中に': {
    110: 'ミミックがいるよ',
    120: 'ミミックはいないよ',
    130: 'ミミックは0匹いる',
    131: 'ミミックは1匹いる',
    132: 'ミミックは2匹いる',
    133: 'ミミックは3匹いる',
    134: 'ミミックは4匹いる',
    135: 'ミミックは5匹いる',
    136: 'ミミックは6匹いる',
    137: 'ミミックは7匹いる',
    138: 'ミミックは8匹いる',
    139: 'ミミックは9匹いる'
  },
  '黒い宝箱の中に': {
    210: 'ミミックがいるよ',
    220: 'ミミックはいないよ',
    230: 'ミミックは0匹いる',
    231: 'ミミックは1匹いる',
    232: 'ミミックは2匹いる',
    233: 'ミミックは3匹いる',
    234: 'ミミックは4匹いる',
    235: 'ミミックは5匹いる',
    236: 'ミミックは6匹いる',
    237: 'ミミックは7匹いる',
    238: 'ミミックは8匹いる',
    239: 'ミミックは9匹いる'
  },
  '一番上の列に': {
    310: 'ミミックがいるよ',
    320: 'ミミックはいないよ'
  },
  '一番下の列に': {
    410: 'ミミックがいるよ',
    420: 'ミミックはいないよ'
  },
  '一番左の列に': {
    510: 'ミミックがいるよ',
    520: 'ミミックはいないよ'
  },
  '一番右の列に': {
    610: 'ミミックがいるよ',
    620: 'ミミックはいないよ'
  },
  '上の列と下の列は': {
    1210: '上の方がミミックが多い',
    1220: '下の方がミミックが多い'
  },
  '左の列と右の列は': {
    1310: '左の方がミミックが多い',
    1320: '右の方がミミックが多い'
  },
  '赤宝箱と': {
    1410: '青宝箱は、赤宝箱の方がミミックが多い',
    1420: '青宝箱は、青宝箱の方がミミックが多い',
    1421: '青宝箱のミミックの数は同じ',
    1430: '黒宝箱は、赤宝箱の方がミミックが多い',
    1440: '黒宝箱は、黒宝箱の方がミミックが多い',
    1441: '黒宝箱のミミックの数は同じ'
  },
  '青宝箱と': {
    1510: '赤宝箱は、青宝箱の方がミミックが多い',
    1520: '赤宝箱は、赤宝箱の方がミミックが多い',
    1521: '赤宝箱のミミックの数は同じ',
    1530: '黒宝箱は、青宝箱の方がミミックが多い',
    1540: '黒宝箱は、黒宝箱の方がミミックが多い',
    1541: '黒宝箱のミミックの数は同じ'
  },
  '黒宝箱と': {
    1610: '赤宝箱は、黒宝箱の方がミミックが多い',
    1620: '赤宝箱は、赤宝箱の方がミミックが多い',
    1621: '赤宝箱のミミックの数は同じ',
    1630: '青宝箱は、黒宝箱の方がミミックが多い',
    1640: '青宝箱は、青宝箱の方がミミックが多い',
    1641: '青宝箱のミミックの数は同じ'
  },
  '私は': {
    1700: 'ミミックじゃない'
  }
};

window.CACHE = {
  TD_HTML: null
};

$().ready(function() {
  $('#num_x, #num_y').on('change', reset);
  $('#judge').on('click', judge);
  $('#clear').on('click', clear);
  init();
  return debug();
});

debug = function() {
  var color, colors, cond, conds, index, j, l, len, len1, len2, o, results;
  colors = [];
  conds = [];
  $('#num_x').val(3);
  $('#num_y').val(3);
  reset();
  $('#num_mimic').val(2);
  $('#num_money').val(0);
  $('#num_equip').val(0);
  $('#num_commodity').val(0);
  for (index = j = 0, len = colors.length; j < len; index = ++j) {
    color = colors[index];
    $('select.box').eq(index).selectpicker('val', color);
  }
  for (index = l = 0, len1 = conds.length; l < len1; index = ++l) {
    cond = conds[index];
    $('.cond1').eq(index).val(cond2cond1(cond));
  }
  $('.cond1').each(function() {
    return changeCond2.bind(this)();
  });
  results = [];
  for (index = o = 0, len2 = conds.length; o < len2; index = ++o) {
    cond = conds[index];
    results.push($('.cond2').eq(index).val(cond));
  }
  return results;
};

cond2cond1 = function(cond) {
  var cond1, cond2japanese, id, obj, ref;
  ref = window.CONDS;
  for (cond1 in ref) {
    obj = ref[cond1];
    for (id in obj) {
      cond2japanese = obj[id];
      if (Number(id) === Number(cond)) {
        return cond1;
      }
    }
  }
  return null;
};

init = function() {
  var index, j, ref, ref1;
  $('#num_x, #num_y').html('');
  for (index = j = ref = window.CONFIG.FIELD_MIN, ref1 = window.CONFIG.FIELD_MAX; (ref <= ref1 ? j <= ref1 : j >= ref1); index = ref <= ref1 ? ++j : --j) {
    $('#num_x, #num_y').append($('<option>').attr('value', index).html(index));
  }
  $('#num_x, #num_y').val(2);
  return reset();
};

clear = function() {
  var numMimic;
  numMimic = $('#num_mimic').val();
  reset();
  return $('#num_mimic').val(numMimic);
};

reset = function() {
  var cellNum, index, j, l, ref, ref1, tr, x, xIndex, y, yIndex;
  x = getX();
  y = getY();
  cellNum = getCellNum();
  $('#num_mimic, #num_money, #num_equip, #num_commodity').html('');
  $('#field tbody').html('');
  for (yIndex = j = 0, ref = y; (0 <= ref ? j < ref : j > ref); yIndex = 0 <= ref ? ++j : --j) {
    tr = $('<tr>');
    for (xIndex = l = 0, ref1 = x; (0 <= ref1 ? l < ref1 : l > ref1); xIndex = 0 <= ref1 ? ++l : --l) {
      index = yIndex * x + xIndex;
      tr.append(getTd(index));
      $('#num_mimic, #num_money, #num_equip, #num_commodity').append($('<option>').html(index).attr('value', index));
    }
    $('#field tbody').append(tr);
  }
  $('#field tbody').find('.box').selectpicker({
    noneSelectedText: '',
    width: 'fit'
  });
  return $('#num_mimic, #num_money, #num_equip, #num_commodity').append($('<option>').html(cellNum).attr('value', cellNum));
};

getTd = function(index) {
  var obj, ref, td, title;
  if (window.CACHE.TD_HTML === null) {
    window.CACHE.TD_HTML = $('#cell_sample').html();
  }
  td = $('<td>').html(window.CACHE.TD_HTML).addClass('cell center').attr('data-index', index);
  td.find('.cond1, .cond2').html('');
  td.find('.cond1').append($('<option>').html('').attr('value', 0));
  ref = window.CONDS;
  for (title in ref) {
    obj = ref[title];
    td.find('.cond1').append($('<option>').html(title));
  }
  td.find('.cond1').on('change', changeCond2);
  return td;
};

changeCond2 = function() {
  var cond1, cond2, condId, ref, results, text;
  cond1 = $(this).val();
  cond2 = $(this).parent().find('.cond2');
  cond2.html('').append($('<option>').html('').attr('value', 0));
  ref = window.CONDS[cond1];
  results = [];
  for (condId in ref) {
    text = ref[condId];
    results.push(cond2.append($('<option>').html(text).attr('value', condId)));
  }
  return results;
};

judge = function() {
  var cellNum, colors, conds, numCommodity, numEquip, numMimic, numMoney, numNotMimic, patterns, stockedIndexes, validPattern, validPatternOnlyMimicResearch, x, y;
  x = getX();
  y = getY();
  cellNum = getCellNum();
  numMimic = getNumMimic();
  numMoney = getNumMoney();
  numEquip = getNumEquip();
  numCommodity = getNumCommodity();
  conds = Utl.arrayFill(getCellNum());
  colors = Utl.arrayFill(getCellNum());
  [numMimic, numMoney, numEquip, numCommodity] = [getNumMimic(), getNumMoney(), getNumEquip(), getNumCommodity()];
  $('.cell').each(function() {
    var box, cond, index;
    index = Number($(this).attr('data-index'));
    box = Number($(this).find('select.box').eq(0).val());
    box = Utl.inArray(box, [window.COLORS.RED, window.COLORS.BLUE, window.COLORS.BLACK]) ? box : window.COLORS.RED;
    cond = Number($(this).find('.cond2').eq(0).val());
    conds[index] = cond;
    return colors[index] = box;
  });
  // インデックス一覧
  stockedIndexes = {
    COLOR: getColorIndexes(colors), // 色ごと
    LINE: getLineIndexes(colors, x, y), // 列ごと
    NEAR: getNearIndexes(colors, x, y), // 自身の隣
    COLOR_NEAR: getColorNearIndexes(colors, x, y) // 色の隣
  };
  console.log('conds:', conds);
  console.log('colors:', colors);
  console.log('stockedIndexes', stockedIndexes);
  // まずはミミックだけを仮定する
  patterns = genPattern([cellNum - numMimic, numMimic, 0, 0, 0]);
  validPatternOnlyMimicResearch = getValidPattern(conds, colors, stockedIndexes, patterns);
  console.log('validPatternOnlyMimicResearch', validPatternOnlyMimicResearch);
  // アイテム種別を考慮する必要がないか、この時点でミミックが確定できていれば終了
  if (mustConsiderType(conds) || checkMimic(validPatternOnlyMimicResearch, numMimic)) {
    return viewTitle(validPatternOnlyMimicResearch);
  }
  // 確定をのぞいてさらに探索
  numNotMimic = (cellNum - numMimic) === (numEquip + numMoney + numCommodity) ? 0 : (numEquip = numMoney = numCommodity = 0, cellNum - numMimic);
  patterns = genPattern([numNotMimic, numMimic, numEquip, numMoney, numCommodity], validPatternOnlyMimicResearch);
  validPattern = getValidPattern(conds, colors, stockedIndexes, patterns);
  console.log('validPattern', validPattern);
  // 全探索したので最終回答
  return viewTitle(validPattern);
};

viewTitle = function(views) {
  var className, html, index, j, len, results, typeConsts;
  $('td, .title').removeClass('mimic money equip commodity unknown');
  results = [];
  for (index = j = 0, len = views.length; j < len; index = ++j) {
    typeConsts = views[index];
    [className, html] = (function() {
      if (typeConsts.length > 1) {
        if (Utl.inArray(window.CONSTS.MIMIC, typeConsts)) {
          return ['unknown', '？'];
        } else {
          return ['not_mimic', '宝'];
        }
      } else {
        switch (typeConsts[0]) {
          case window.CONSTS.MIMIC:
            return ['mimic', 'ミミック'];
          case window.CONSTS.NOT_MIMIC:
            return ['not_mimic', '宝'];
          case window.CONSTS.EQUIP:
            return ['equip', '装備'];
          case window.CONSTS.MONEY:
            return ['money', 'お金'];
          case window.CONSTS.COMMODITY:
            return ['commodity', '消費アイテム'];
          default:
            return ['', ''];
        }
      }
    })();
    $('.title').eq(index).addClass(className).html(html);
    results.push($('td').eq(index).addClass(className));
  }
  return results;
};

// 宝の種別を考慮しないといけないか
mustConsiderType = function(conds) {
  return false;
};

checkMimic = function(validPattern, numMimic) {
  var index, j, len, mimic, typeConstArray;
  mimic = 0;
  for (index = j = 0, len = validPattern.length; j < len; index = ++j) {
    typeConstArray = validPattern[index];
    if (typeConstArray.length === 1 && typeConstArray[0] === window.CONSTS.MIMIC) {
      mimic++;
    }
  }
  console.log('checkMimic:', mimic === numMimic);
  return mimic === numMimic;
};

getValidPattern = function(conds, colors, stockedIndexes, patterns) {
  var collects, index, j, l, len, len1, len2, o, pattern, res, type, valid, valids;
  valids = [];
  for (j = 0, len = patterns.length; j < len; j++) {
    pattern = patterns[j];
    res = isValidPattern(conds, colors, stockedIndexes, pattern);
    if (res) {
      valids.push(pattern);
    }
  }
  console.log('valids', valids);
  collects = Utl.arrayFill(colors.length, []);
  for (l = 0, len1 = valids.length; l < len1; l++) {
    valid = valids[l];
    for (index = o = 0, len2 = valid.length; o < len2; index = ++o) {
      type = valid[index];
      if (!Utl.inArray(type, collects[index])) {
        collects[index].push(type);
      }
    }
  }
  return collects;
};

isValidPattern = function(conds, colors, stockedIndexes, pattern) {
  var cond, index, isMimic, j, len, res;
  console.log(conds, pattern);
  for (index = j = 0, len = conds.length; j < len; index = ++j) {
    cond = conds[index];
    isMimic = pattern[index] === window.CONSTS.MIMIC;
    res = (function() {
      switch (cond) {
        // ある宝箱の隣にミミックがいる
        // 上
        case 710:
          return isContainType(pattern, stockedIndexes.NEAR[index][window.DIRECTIONS.UP], window.CONSTS.MIMIC);
        // 下
        case 810:
          return isContainType(pattern, stockedIndexes.NEAR[index][window.DIRECTIONS.DOWN], window.CONSTS.MIMIC);
        // 左
        case 910:
          return isContainType(pattern, stockedIndexes.NEAR[index][window.DIRECTIONS.LEFT], window.CONSTS.MIMIC);
        // 右
        case 1010:
          return isContainType(pattern, stockedIndexes.NEAR[index][window.DIRECTIONS.RIGHT], window.CONSTS.MIMIC);
        // ある宝箱の隣にミミックがいない
        // 上
        case 720:
          return isNotContainType(pattern, stockedIndexes.NEAR[index][window.DIRECTIONS.UP], window.CONSTS.MIMIC);
        // 下
        case 820:
          return isNotContainType(pattern, stockedIndexes.NEAR[index][window.DIRECTIONS.DOWN], window.CONSTS.MIMIC);
        // 左
        case 920:
          return isNotContainType(pattern, stockedIndexes.NEAR[index][window.DIRECTIONS.LEFT], window.CONSTS.MIMIC);
        // 右
        case 1020:
          return isNotContainType(pattern, stockedIndexes.NEAR[index][window.DIRECTIONS.RIGHT], window.CONSTS.MIMIC);
        // ある色の宝箱にミミックがいる
        // 赤
        case 10:
          return isContainType(pattern, stockedIndexes.COLOR[window.COLORS.RED], window.CONSTS.MIMIC);
        // 青
        case 110:
          return isContainType(pattern, stockedIndexes.COLOR[window.COLORS.BLUE], window.CONSTS.MIMIC);
        // 黒
        case 210:
          return isContainType(pattern, stockedIndexes.COLOR[window.COLORS.BLACK], window.CONSTS.MIMIC);
        // ある色の宝箱にミミックがn匹いる
        // 赤
        case 30:
        case 31:
        case 32:
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
          return isContainTypeCount(pattern, stockedIndexes.COLOR[window.COLORS.RED], window.CONSTS.MIMIC, cond % 30);
        // 青
        case 130:
        case 131:
        case 132:
        case 133:
        case 134:
        case 135:
        case 136:
        case 137:
        case 138:
        case 139:
          return isContainTypeCount(pattern, stockedIndexes.COLOR[window.COLORS.BLUE], window.CONSTS.MIMIC, cond % 130);
        // 黒
        case 230:
        case 231:
        case 232:
        case 233:
        case 234:
        case 235:
        case 236:
        case 237:
        case 238:
        case 239:
          return isContainTypeCount(pattern, stockedIndexes.COLOR[window.COLORS.BLACK], window.CONSTS.MIMIC, cond % 230);
        // ある色の宝箱にミミックがいない
        // 赤
        case 20:
          return isNotContainType(pattern, stockedIndexes.COLOR[window.COLORS.RED], window.CONSTS.MIMIC);
        // 青
        case 120:
          return isNotContainType(pattern, stockedIndexes.COLOR[window.COLORS.BLUE], window.CONSTS.MIMIC);
        // 黒
        case 220:
          return isNotContainType(pattern, stockedIndexes.COLOR[window.COLORS.BLACK], window.CONSTS.MIMIC);
        // ある列にミミックがいる
        // 上
        case 310:
          return isContainType(pattern, stockedIndexes.LINE[window.DIRECTIONS.UP], window.CONSTS.MIMIC);
        // 下
        case 410:
          return isContainType(pattern, stockedIndexes.LINE[window.DIRECTIONS.DOWN], window.CONSTS.MIMIC);
        // 左
        case 510:
          return isContainType(pattern, stockedIndexes.LINE[window.DIRECTIONS.LEFT], window.CONSTS.MIMIC);
        // 右
        case 610:
          return isContainType(pattern, stockedIndexes.LINE[window.DIRECTIONS.RIGHT], window.CONSTS.MIMIC);
        // ある列にミミックがいない
        // 上
        case 320:
          return isNotContainType(pattern, stockedIndexes.LINE[window.DIRECTIONS.UP], window.CONSTS.MIMIC);
        // 下
        case 420:
          return isNotContainType(pattern, stockedIndexes.LINE[window.DIRECTIONS.DOWN], window.CONSTS.MIMIC);
        // 左
        case 520:
          return isNotContainType(pattern, stockedIndexes.LINE[window.DIRECTIONS.LEFT], window.CONSTS.MIMIC);
        // 右
        case 620:
          return isNotContainType(pattern, stockedIndexes.LINE[window.DIRECTIONS.RIGHT], window.CONSTS.MIMIC);
        // ミミック同士は隣り合った位置に
        // いる
        case 1100:
          return isMimicNearly(pattern, stockedIndexes.NEAR);
        // いない
        case 1110:
          return !isMimicNearly(pattern, stockedIndexes.NEAR);
        
        // 上の列と下の列は
        // 上の列の方がミミックが多い
        case 1210:
          return compareIndexes(pattern, stockedIndexes.LINE[window.DIRECTIONS.UP], stockedIndexes.LINE[window.DIRECTIONS.DOWN], -1);
        // 下の列の方がミミックが多い
        case 1220:
          return compareIndexes(pattern, stockedIndexes.LINE[window.DIRECTIONS.UP], stockedIndexes.LINE[window.DIRECTIONS.DOWN], 1);
        // 左の列と右の列は
        // 左の列の方がミミックが多い
        case 1310:
          return compareIndexes(pattern, stockedIndexes.LINE[window.DIRECTIONS.LEFT], stockedIndexes.LINE[window.DIRECTIONS.RIGHT], -1);
        // 右の列の方がミミックが多い
        case 1320:
          return compareIndexes(pattern, stockedIndexes.LINE[window.DIRECTIONS.LEFT], stockedIndexes.LINE[window.DIRECTIONS.RIGHT], 1);
        // 赤宝箱と青宝箱は
        // 赤宝箱の方がミミックが多い
        case 1410:
        case 1520:
          return compareIndexes(pattern, stockedIndexes.COLOR[window.COLORS.RED], stockedIndexes.COLOR[window.COLORS.BLUE], -1);
        // 青宝箱の方がミミックが多い
        case 1420:
        case 1510:
          return compareIndexes(pattern, stockedIndexes.COLOR[window.COLORS.RED], stockedIndexes.COLOR[window.COLORS.BLUE], 1);
        // 同じ
        case 1421:
        case 1521:
          return compareIndexes(pattern, stockedIndexes.COLOR[window.COLORS.RED], stockedIndexes.COLOR[window.COLORS.BLUE], 0);
        // 赤宝箱と黒宝箱は
        // 赤宝箱の方がミミックが多い
        case 1430:
        case 1620:
          return compareIndexes(pattern, stockedIndexes.COLOR[window.COLORS.RED], stockedIndexes.COLOR[window.COLORS.BLACK], -1);
        // 黒宝箱の方がミミックが多い
        case 1440:
        case 1610:
          return compareIndexes(pattern, stockedIndexes.COLOR[window.COLORS.RED], stockedIndexes.COLOR[window.COLORS.BLACK], 1);
        // 同じ
        case 1441:
        case 1621:
          return compareIndexes(pattern, stockedIndexes.COLOR[window.COLORS.RED], stockedIndexes.COLOR[window.COLORS.BLACK], 0);
        // 青宝箱と黒宝箱は
        // 青宝箱の方がミミックが多い
        case 1530:
        case 1640:
          return compareIndexes(pattern, stockedIndexes.COLOR[window.COLORS.BLUE], stockedIndexes.COLOR[window.COLORS.BLACK], -1);
        // 黒宝箱の方がミミックが多い
        case 1540:
        case 1630:
          return compareIndexes(pattern, stockedIndexes.COLOR[window.COLORS.BLUE], stockedIndexes.COLOR[window.COLORS.BLACK], 1);
        // 同じ
        case 1541:
        case 1641:
          return compareIndexes(pattern, stockedIndexes.COLOR[window.COLORS.BLUE], stockedIndexes.COLOR[window.COLORS.BLACK], 0);
        // 私はミミックじゃない
        case 1700:
          return isNotContainType(pattern, [index], window.CONSTS.MIMIC);
        default:
          return (isMimic = false) || true;
      }
    })();
    if (isMimic) {
      res = !res;
    }
    console.log(cond, res);
    if (!res) {
      return false;
    }
  }
  return true;
};

// [win]
// 0 : 同じ
// -1: indexes1が多い
// 1 : indexes2が多い
compareIndexes = function(pattern, indexes1, indexes2, win) {
  var index, j, l, len, len1, mimic1, mimic2;
  mimic1 = mimic2 = 0;
  for (j = 0, len = indexes1.length; j < len; j++) {
    index = indexes1[j];
    if (pattern[index] === window.CONSTS.MIMIC) {
      mimic1++;
    }
  }
  for (l = 0, len1 = indexes2.length; l < len1; l++) {
    index = indexes2[l];
    if (pattern[index] === window.CONSTS.MIMIC) {
      mimic2++;
    }
  }
  // line1が多い
  if (win < 0) {
    return mimic1 > mimic2;
  // line2が多い
  } else if (win > 0) {
    return mimic1 < mimic2;
  } else {
    return mimic1 === mimic2;
  }
};

// ミミック同士は隣あった位置にいるか
isMimicNearly = function(pattern, nearIndexes) {
  var index, index1, index2, indexes, isExist, j, key, l, len, mimics, o, ref, ref1, ref2, ref3, typeConst;
  mimics = [];
  for (index = j = 0, len = pattern.length; j < len; index = ++j) {
    typeConst = pattern[index];
    if (typeConst === window.CONSTS.MIMIC) {
      mimics.push(index);
    }
  }
  for (index1 = l = 0, ref = mimics.length; (0 <= ref ? l < ref : l > ref); index1 = 0 <= ref ? ++l : --l) {
    for (index2 = o = ref1 = index1 + 1, ref2 = mimics.length; (ref1 <= ref2 ? o < ref2 : o > ref2); index2 = ref1 <= ref2 ? ++o : --o) {
      isExist = false;
      ref3 = nearIndexes[mimics[index1]];
      for (key in ref3) {
        indexes = ref3[key];
        if (Utl.inArray(mimics[index2], indexes)) {
          isExist = true;
        }
      }
      if (!isExist) {
        return false;
      }
    }
  }
  return true;
};

// 指定したインデックスに指定したタイプがいるか
isContainType = function(pattern, indexes, typeConst) {
  var index, j, len;
  for (j = 0, len = indexes.length; j < len; j++) {
    index = indexes[j];
    if (typeConst === window.CONSTS.NOT_MIMIC && pattern[index] !== window.CONSTS.MIMIC) {
      // ミミック以外を指定で、ミミックではない
      return true;
    }
    if (typeConst === pattern[index]) {
      // タイプ合致
      return true;
    }
  }
  return false;
};

// 指定したインデックスに指定したタイプがn匹いるか
isContainTypeCount = function(pattern, indexes, typeConst, count) {
  var index, j, len, nowCount;
  nowCount = 0;
  for (j = 0, len = indexes.length; j < len; j++) {
    index = indexes[j];
    if (typeConst === window.CONSTS.NOT_MIMIC && pattern[index] !== window.CONSTS.MIMIC) {
      nowCount++;
    } else if (typeConst === pattern[index]) {
      nowCount++;
    }
  }
  return count === nowCount;
};

// 指定したインデックスに指定したタイプがいないか
isNotContainType = function(pattern, indexes, typeConst) {
  var index, j, len;
  for (j = 0, len = indexes.length; j < len; j++) {
    index = indexes[j];
    if (typeConst === window.CONSTS.NOT_MIMIC && pattern[index] !== window.CONSTS.MIMIC) {
      // ミミック以外が含まれていないのに、ミミック以外が含まれている
      return false;
    }
    if (typeConst === window.CONSTS.MIMIC && pattern[index] === window.CONSTS.MIMIC) {
      // ミミックが含まれていないのに、ミミックである
      return false;
    }
    if (typeConst === pattern[index]) {
      // タイプ合致
      return false;
    }
  }
  return true;
};

// 特定の色の宝箱のインデックス
getColorIndexes = function(colors) {
  var color, index, j, len, name, num, ref, res;
  res = {};
  ref = window.COLORS;
  for (name in ref) {
    num = ref[name];
    res[num] = [];
  }
  for (index = j = 0, len = colors.length; j < len; index = ++j) {
    color = colors[index];
    res[color].push(index);
  }
  return res;
};

// 特定の列のインデックス
getLineIndexes = function(colors, x, y) {
  var dirName, dirNum, index, j, l, o, q, ref, ref1, ref2, ref3, ref4, ref5, res;
  res = {};
  ref = window.DIRECTIONS;
  for (dirName in ref) {
    dirNum = ref[dirName];
    res[dirNum] = [];
  }
  for (index = j = 0, ref1 = x; (0 <= ref1 ? j < ref1 : j > ref1); index = 0 <= ref1 ? ++j : --j) {
    // 上
    res[window.DIRECTIONS.UP].push(index);
  }
  for (index = l = ref2 = x * y - x, ref3 = x * y; (ref2 <= ref3 ? l < ref3 : l > ref3); index = ref2 <= ref3 ? ++l : --l) {
    // 下
    res[window.DIRECTIONS.DOWN].push(index);
  }
  for (index = o = 0, ref4 = y; (0 <= ref4 ? o < ref4 : o > ref4); index = 0 <= ref4 ? ++o : --o) {
    // 左
    res[window.DIRECTIONS.LEFT].push(index * x);
  }
  for (index = q = 0, ref5 = y; (0 <= ref5 ? q < ref5 : q > ref5); index = 0 <= ref5 ? ++q : --q) {
    // 右
    res[window.DIRECTIONS.RIGHT].push((index + 1) * x - 1);
  }
  return res;
};

// 特定の宝箱の隣接のインデックス
getNearIndexes = function(colors, x, y) {
  var color, dirName, dirNum, down, index, j, l, left, len, ref, ref1, res, right, up;
  res = Utl.arrayFill(colors.length, {});
  for (index = j = 0, ref = res.length; (0 <= ref ? j < ref : j > ref); index = 0 <= ref ? ++j : --j) {
    ref1 = window.DIRECTIONS;
    for (dirName in ref1) {
      dirNum = ref1[dirName];
      res[index][dirNum] = [];
    }
  }
  for (index = l = 0, len = colors.length; l < len; index = ++l) {
    color = colors[index];
    // 上
    up = index - x;
    if ((0 <= up && up < x * y)) {
      res[index][window.DIRECTIONS.UP].push(up);
    }
    // 下
    down = index + x;
    if ((0 <= down && down < x * y)) {
      res[index][window.DIRECTIONS.DOWN].push(down);
    }
    // 左
    left = index - 1;
    if ((0 <= left && left < x * y) && Math.floor(index / x) === Math.floor(left / x)) {
      res[index][window.DIRECTIONS.LEFT].push(left);
    }
    // 右
    right = index + 1;
    if ((0 <= right && right < x * y) && Math.floor(index / x) === Math.floor(right / x)) {
      res[index][window.DIRECTIONS.RIGHT].push(right);
    }
  }
  return res;
};

// 特定の色の宝箱の隣接のインデックス
getColorNearIndexes = function(colors, x, y) {
  var color, colorName, colorNum, dirName, dirNum, down, index, j, left, len, ref, ref1, res, right, up;
  res = {};
  ref = window.COLORS;
  for (colorName in ref) {
    colorNum = ref[colorName];
    res[colorNum] = {};
    ref1 = window.DIRECTIONS;
    for (dirName in ref1) {
      dirNum = ref1[dirName];
      res[colorNum][dirNum] = [];
    }
  }
  for (index = j = 0, len = colors.length; j < len; index = ++j) {
    color = colors[index];
    // 上
    up = index - x;
    if ((0 <= up && up < x * y)) {
      res[color][window.DIRECTIONS.UP].push(up);
    }
    // 下
    down = index + x;
    if ((0 <= down && down < x * y)) {
      res[color][window.DIRECTIONS.DOWN].push(down);
    }
    // 左
    left = index - 1;
    if ((0 <= left && left < x * y) && Math.floor(index / x) === Math.floor(left / x)) {
      res[color][window.DIRECTIONS.LEFT].push(left);
    }
    // 右
    right = index + 1;
    if ((0 <= right && right < x * y) && Math.floor(index / x) === Math.floor(right / x)) {
      res[color][window.DIRECTIONS.RIGHT].push(right);
    }
  }
  return res;
};

getX = function() {
  return Number($('#num_x').val());
};

getY = function() {
  return Number($('#num_y').val());
};

getCellNum = function() {
  return getX() * getY();
};

getNumMimic = function() {
  return Number($('#num_mimic').val());
};

getNumMoney = function() {
  return Number($('#num_money').val());
};

getNumEquip = function() {
  return Number($('#num_equip').val());
};

getNumCommodity = function() {
  return Number($('#num_commodity').val());
};

// [confirmIndexes]
// indexにあわせて確定のtypeConstが入っている
genPattern = function(ary, confirmIndexes = null) {
  var all, consts, constsArray, getPatternFunc, index, j, l, len, len1, num, remain, total;
  // [ミミック以外(オールマイティ), ミミック, 装備, お金, 消費アイテム]
  consts = [window.CONSTS.NOT_MIMIC, window.CONSTS.MIMIC, window.CONSTS.EQUIP, window.CONSTS.MONEY, window.CONSTS.COMMODITY];
  remain = Utl.clone(ary);
  total = 0;
  for (j = 0, len = ary.length; j < len; j++) {
    num = ary[j];
    total += num;
  }
  if (confirmIndexes !== null) {
    for (index = l = 0, len1 = confirmIndexes.length; l < len1; index = ++l) {
      constsArray = confirmIndexes[index];
      if (constsArray.length === 1 && constsArray[0] !== window.CONSTS.NOT_MIMIC) {
        ary[constsArray[0]]--;
      }
    }
  }
  all = [];
  getPatternFunc = function(m, remain) {
    var condCommodity, condEquip, condMoney, condNotMimic, len2, newM, newRemain, o, results;
    if (m.length === total) {
      all.push(m);
      return true;
    }
    results = [];
    for (index = o = 0, len2 = remain.length; o < len2; index = ++o) {
      num = remain[index];
      if (num <= 0) {
        continue;
      }
      // 該当しないなら飛ばす
      if (confirmIndexes !== null) {
        condNotMimic = Utl.inArray(window.CONSTS.NOT_MIMIC, confirmIndexes[m.length]);
        condEquip = Utl.inArray(window.CONSTS.EQUIP, confirmIndexes[m.length]);
        condMoney = Utl.inArray(window.CONSTS.MONEY, confirmIndexes[m.length]);
        condCommodity = Utl.inArray(window.CONSTS.COMMODITY, confirmIndexes[m.length]);
        if (index === window.CONSTS.NOT_MIMIC) {
          if (!condNotMimic && !condEquip && !condMoney && !condCommodity) {
            continue;
          }
        } else if (Utl.inArray(index, [window.CONSTS.EQUIP, window.CONSTS.MONEY, window.CONSTS.COMMODITY])) {
          if (!condNotMimic && !Utl.inArray(index, confirmIndexes[m.length])) {
            continue;
          }
        } else if (index === window.CONSTS.MIMIC) {
          if (!Utl.inArray(index, confirmIndexes[m.length])) {
            continue;
          }
        }
      }
      newM = Utl.clone(m);
      newRemain = Utl.clone(remain);
      newRemain[index]--;
      newM.push(consts[index]);
      results.push(getPatternFunc(newM, newRemain));
    }
    return results;
  };
  getPatternFunc([], remain);
  console.log('組み合わせ:', all);
  return all;
};

window.Utl = (function() {
  class Utl {
    //###########################################

    // 数値にカンマを入れる

    // @param Number num
    // @return String

    //###########################################
    static numFormat(num) {
      return String(num).replace(/(\d)(?=(\d\d\d)+(?!\d))/g, '$1,');
    }

    //###########################################

    // min <= n <= max の整数乱数を生成

    // @param Number min
    // @param Number max
    // @return String

    //###########################################
    static rand(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    //###########################################

    // length 文字のランダムな文字列を生成

    // @param Number length
    // @return String

    //###########################################
    static genPassword(length = 4) {
      var chars, i, j, ref, res;
      chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
      res = '';
      for (i = j = 0, ref = length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        res += chars.substr(this.rand(0, chars.length - 1), 1);
      }
      return res;
    }

    //###########################################

    // アドレスバーを変更

    // @param String url
    // @return String

    //###########################################
    static adrBar(url) {
      return window.history.replaceState('', '', '' + url);
    }

    //###########################################

    // getクエリを取得

    // @return Object

    //###########################################
    static getQuery(key = null, defaultValue = null) {
      var j, k, len, p, params, query, res, v;
      query = document.location.search.substring(1);
      params = query.split('&');
      res = {};
      for (j = 0, len = params.length; j < len; j++) {
        p = params[j];
        [k, v] = p.split('=');
        res[k] = v;
      }
      if (key === null) {
        return res;
      }
      if (res[key] != null) {
        return res[key];
      }
      return defaultValue;
    }

    //###########################################

    // 数値を min <= num < max の範囲で正規化する

    // @param Number num
    // @param Number min
    // @param Number max
    // @return String

    //###########################################
    static normalize(num, min = 0, max = 1) {
      var range;
      range = Math.abs(max - min);
      if (num < min) {
        num += range * Math.ceil(Math.abs(num - min) / range);
      } else if (max <= num) {
        num -= range * (Math.floor(Math.abs(num - max) / range) + 1);
      }
      return num;
    }

    //###########################################

    // 現在秒を取得

    // @return int

    //###########################################
    static time(date = null) {
      if (date === null) {
        date = new Date();
      }
      return Math.floor(+date / 1000);
    }

    //###########################################

    // 現在ミリ秒を取得

    // @return int/float

    //###########################################
    static militime(date = null, getAsFloat = false) {
      if (date === null) {
        date = new Date();
      }
      return +date / (getAsFloat ? 1000 : 1);
    }

    //###########################################

    // 現在日を YYYY-MM-DD で取得

    // @param Date date
    // @param String dateSep 日付のセパレータ
    // @return String

    //###########################################
    static dateStr(date = null, dateSep = '-') {
      if (date === null) {
        date = new Date();
      }
      return '' + this.zerofill(date.getFullYear(), 4) + dateSep + this.zerofill(date.getMonth() + 1, 2) + dateSep + this.zerofill(date.getDate(), 2);
    }

    //###########################################

    // 現在日時を YYYY-MM-DD HH:ii:ssで取得

    // @param Date date
    // @param String dateSep 日付のセパレータ
    // @param String timeSep 時間のセパレータ
    // @param boolean betweenSep 日付と時間の間の文字
    // @return String

    //###########################################
    static datetimeStr(date = null, dateSep = '-', timeSep = ':', betweenSep = ' ') {
      if (date === null) {
        date = new Date();
      }
      return this.dateStr(date, dateSep) + betweenSep + this.zerofill(date.getHours(), 2) + timeSep + this.zerofill(date.getMinutes(), 2) + timeSep + this.zerofill(date.getSeconds(), 2);
    }

    //###########################################

    // baseDate と targetDate の時刻の差を「何分前」のような表記で取得

    // @param Date targetDate 対象となる日時
    // @param Date baseDate 基準となる日時
    // @param unsigned_int nowSec ついさっき表記する上限の秒数
    // @param String agoStr ついさっき表記の文字列
    // @param String secStr 秒の表記
    // @param String minStr 分の表記
    // @param String hourStr 時間の表記
    // @param String dayStr 日の表記
    // @param String monStr 月の表記
    // @param String yearStr 年の表記
    // @return String

    //###########################################
    static difftime(targetDate, baseDate = null, nowSec = 0, nowStr = 'ついさっき', agoStr = '前', secStr = '秒', minStr = '分', hourStr = '時間', dayStr = '日', monStr = '月', yearStr = '年') {
      var baseTime, d, diffTime, h, m, mo, targetTime, y;
      if (baseDate === null) {
        baseTime = this.time();
      }
      targetTime = this.time(targetDate);
      diffTime = baseTime - targetTime;
      if (diffTime < 0) {
        // 未来
        return null;
      }
      if (nowSec >= diffTime) {
        // ついさっきと表示する基準の秒数
        return nowStr;
      }
      // 一年以上
      y = Math.floor(diffTime / (60 * 60 * 24 * 30 * 12));
      if (y > 0) {
        return '' + y + yearStr + agoStr;
      }
      diffTime -= y * (60 * 60 * 24 * 30 * 12);
      // 一ヶ月以上
      mo = Math.floor(diffTime / (60 * 60 * 24 * 30));
      if (mo > 0) {
        return '' + mo + monStr + agoStr;
      }
      diffTime -= mo * (60 * 60 * 24 * 30);
      // 一日以上
      d = Math.floor(diffTime / (60 * 60 * 24));
      if (d > 0) {
        return '' + d + dayStr + agoStr;
      }
      diffTime -= d * (60 * 60 * 24);
      // 一時間以上
      h = Math.floor(diffTime / (60 * 60));
      if (h > 0) {
        return '' + h + hourStr + agoStr;
      }
      diffTime -= h * (60 * 60);
      // 一分以上
      m = Math.floor(diffTime / 60);
      if (m > 0) {
        return '' + m + minStr + agoStr;
      }
      diffTime -= m * 60;
      if (diffTime > 0) {
        // 一秒以上
        return '' + diffTime + secStr + agoStr;
      }
      // ついさっき
      return nowStr;
    }

    //###########################################

    // 数値をゼロ埋めする

    // @param int num
    // @param int digit 桁数
    // @return int

    //###########################################
    static zerofill(num, digit) {
      return ('' + this.repeat('0', digit) + num).slice(-digit);
    }

    //###########################################

    // str を times 回繰り返した文字列を返す

    // @param String str
    // @param int times
    // @return String

    //###########################################
    static repeat(str, times) {
      return Array(1 + times).join(str);
    }

    //###########################################

    // 配列をシャッフル

    // @param Array ary シャッフルする配列
    // @return Array

    //###########################################
    static shuffle(ary) {
      var i, n;
      n = ary.length;
      while (n) {
        n--;
        i = this.rand(0, n);
        [ary[i], ary[n]] = [ary[n], ary[i]];
      }
      return ary;
    }

    //###########################################

    // 配列 ary に needle が存在するかを調べる

    // @param mixed needle 値
    // @param Array ary
    // @return boolean 存在する場合はtrue, そうでないなら false

    //###########################################
    static inArray(needle, ary) {
      var j, len, v;
      for (j = 0, len = ary.length; j < len; j++) {
        v = ary[j];
        if (v === needle) {
          return true;
        }
      }
      return false;
    }

    //###########################################

    // 配列のコピーを返す

    // @param Array ary
    // @return Array

    //###########################################
    static clone(obj) {
      var res;
      res = obj;
      if ($.isArray(obj)) {
        res = $.extend(true, [], obj);
      } else if (obj instanceof Object) {
        res = $.extend(true, {}, obj);
      }
      return res;
    }

    //###########################################

    // 長さ length の配列を val で満たして返す

    // @param int length
    // @param mixed val
    // @return Array

    //###########################################
    static arrayFill(length, val = null) {
      var i, j, ref, res;
      res = [];
      for (i = j = 0, ref = length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        res[i] = this.clone(val);
      }
      return res;
    }

    //###########################################

    // x * y の配列を val で満たして返す

    // @param int x
    // @param int y 省略時は x と同じ長さ
    // @param mixed val
    // @return Array

    //###########################################
    static array2dFill(x, y = null, val = null) {
      var j, l, ref, ref1, res, xx, yAry, yy;
      if (y === null) {
        y = x;
      }
      res = [];
      yAry = [];
      for (yy = j = 0, ref = y; (0 <= ref ? j < ref : j > ref); yy = 0 <= ref ? ++j : --j) {
        yAry[yy] = this.clone(val);
      }
      for (xx = l = 0, ref1 = x; (0 <= ref1 ? l < ref1 : l > ref1); xx = 0 <= ref1 ? ++l : --l) {
        res[xx] = this.clone(yAry);
      }
      return res;
    }

    //###########################################

    // 配列の合計を返す

    // @param Array ary
    // @return Array

    //###########################################
    static arraySum(ary) {
      var j, len, sum, v;
      sum = 0;
      for (j = 0, len = ary.length; j < len; j++) {
        v = ary[j];
        sum += v;
      }
      return sum;
    }

    //###########################################

    // 配列の最小値を返す

    // @param Array ary
    // @return Array

    //###########################################
    static arrayMin(ary) {
      var j, len, min, v;
      min = null;
      for (j = 0, len = ary.length; j < len; j++) {
        v = ary[j];
        if (min === null || min > v) {
          min = v;
        }
      }
      return min;
    }

    //###########################################

    // 配列の最大値を返す

    // @param Array ary
    // @return Array

    //###########################################
    static arrayMax(ary) {
      var j, len, max, v;
      max = null;
      for (j = 0, len = ary.length; j < len; j++) {
        v = ary[j];
        if (max === null || max < v) {
          max = v;
        }
      }
      return max;
    }

    //###########################################

    // 連想配列のキーの数を返す

    // @param Object object
    // @return int

    //###########################################
    static count(object) {
      return Object.keys(object).length;
    }

    //###########################################

    // uuid を生成（バージョン4）

    // @return String

    //###########################################
    static uuid4() {
      var i, j, random, uuid;
      uuid = '';
      for (i = j = 0; j < 32; i = ++j) {
        random = Math.random() * 16 | 0;
        if (i === 8 || i === 12 || i === 16 || i === 20) {
          uuid += '-';
        }
        uuid += (i === 12 ? 4 : (i === 16 ? random & 3 | 8 : random)).toString(16);
      }
      return uuid;
    }

    //###########################################

    // ローカルストレージの値を削除

    // @param String key
    // @param mixed value
    // @return undefined

    //###########################################
    static delLs(key) {
      return localStorage.removeItem(key);
    }

    //###########################################

    // ローカルストレージに値を設定

    // @param String key
    // @param mixed value
    // @return undefined

    //###########################################
    static setLs(key, value = null) {
      var json;
      if (value === null) {
        // null は削除
        return this.delLs(key);
      }
      json = JSON.stringify(value);
      return localStorage.setItem(key, json);
    }

    //###########################################

    // ローカルストレージから値を取得

    // @param String key
    // @return undefined

    //###########################################
    static getLs(key) {
      var res;
      res = localStorage.getItem(key);
      try {
        res = JSON.parse(res);
      } catch (error) {
        res = null;
      }
      return res;
    }

    //###########################################

    // ミリ秒待つ（要async/await対応ブラウザ＆coffee2.x）

    // @param String key
    // @return undefined

    //###########################################
    static sleep(msec) {
      return new Promise((resolve, reject) => {
        return setTimeout(() => {
          return resolve();
        }, msec);
      });
    }

  };

  //###########################################

  // key-valueとしてIndexedDBを簡単に使うクラス

  //###########################################
  Utl.IndexedDB = (function() {
    class IndexedDB {
      constructor(dbName = 'default', dbVersion = 1) {
        var open;
        this.dbName = dbName;
        this.dbVersion = dbVersion;
        open = window.indexedDB.open(this.dbName, this.dbVersion);
        open.onupgradeneeded = (evt) => {
          var res;
          res = evt.target.result;
          return res.createObjectStore(this.STORE_NAME, {
            keyPath: 'kvstore_key'
          });
        };
        open.onsuccess = (evt) => {
          return this.db = evt.target.result;
        };
      }

      // awaitで使う
      async set(key, value) {
        var request, store, token, transaction;
        await this.waitUnLock();
        token = this.genToken();
        this.lock(token);
        transaction = this.db.transaction(this.STORE_NAME, 'readwrite');
        store = transaction.objectStore(this.STORE_NAME);
        request = store.put({
          kvstore_key: key,
          kvstore_value: JSON.stringify(value)
        });
        request.onsuccess = (evt) => {
          if (token === this.token) {
            return this.capture(true, token);
          } else {
            return this.capture(false, token);
          }
        };
        request.onerror = (evt) => {
          return this.capture(false, token);
        };
        await this.waitCapture();
        if (token === this.token && this.isCaptured) {
          return this.unlock(token);
        } else {
          return false;
        }
      }

      // awaitで使う
      async get(key) {
        var request, store, token, transaction;
        await this.waitUnLock();
        token = this.genToken();
        this.lock(token);
        transaction = this.db.transaction(this.STORE_NAME, 'readonly');
        store = transaction.objectStore(this.STORE_NAME);
        request = store.get(key);
        request.onsuccess = (evt) => {
          var res;
          try {
            res = JSON.parse(evt.target.result.kvstore_value);
          } catch (error) {
            res = null;
          }
          if (token === this.token) {
            return this.capture(res, token);
          } else {
            return this.unlock(token);
          }
        };
        await this.waitCapture();
        if (this.isCaptured) {
          return this.unlock(token);
        } else {
          return null;
        }
      }

      // awaitで使う
      async gets(keys) {
        var j, key, len, request, res, store, token, transaction;
        await this.waitUnLock();
        token = this.genToken();
        this.lock(token);
        res = {};
        transaction = this.db.transaction(this.STORE_NAME, 'readonly');
        store = transaction.objectStore(this.STORE_NAME);
        for (j = 0, len = keys.length; j < len; j++) {
          key = keys[j];
          request = store.get(key);
          request.onsuccess = (evt) => {
            try {
              return res[evt.target.result.kvstore_key] = JSON.parse(evt.target.result.kvstore_value);
            } catch (error) {
              return res[evt.target.result.kvstore_key] = null;
            }
          };
        }
        transaction.oncomplete = (evt) => {
          return this.capture(res, token);
        };
        await this.waitCapture();
        if (this.isCaptured) {
          return this.unlock(token);
        } else {
          return null;
        }
      }

      // awaitで呼ぶ
      async getAllKeys() {
        var keys, request, store, token, transaction;
        await this.waitUnLock();
        token = this.genToken();
        this.lock(token);
        keys = [];
        transaction = this.db.transaction(this.STORE_NAME, 'readonly');
        store = transaction.objectStore(this.STORE_NAME);
        request = store.openCursor();
        request.onsuccess = (evt) => {
          var cursor;
          cursor = evt.target.result;
          if (cursor) {
            keys.push(cursor.key);
            return cursor.continue();
          } else {
            return this.capture(keys, token);
          }
        };
        request.onerror = (evt) => {
          return this.unlock(token);
        };
        await this.waitCapture();
        if (this.isCaptured) {
          return this.unlock(token);
        } else {
          return [];
        }
      }

      destroy() {
        return window.indexedDB.deleteDatabase(this.dbName);
      }

      unlock(token = null) {
        var res;
        if (token === null || token === this.token) {
          res = this.result;
          this.result = null;
          this.isCaptured = false;
          this.locked = null;
          this.token = null;
          this.isLocked = false;
          return res;
        } else {
          return null;
        }
      }

      capture(value, token) {
        if (this.token === token) {
          this.isLocked = true;
          this.isCaptured = true;
          return this.result = value;
        }
      }

      lock(token) {
        this.isLocked = true;
        this.token = token;
        this.isCaptured = false;
        this.locked = +(new Date());
        this.result = null;
        return true;
      }

      async waitUnLock() {
        while (this.isLocked && +(new Date()) - this.locked < this.TIMEOUT_MSEC) {
          await Utl.sleep(this.LOCK_WAIT_MSEC);
        }
        return true;
      }

      async waitCapture() {
        while (!this.isCaptured && +(new Date()) - this.locked < this.TIMEOUT_MSEC) {
          await Utl.sleep(this.LOCK_WAIT_MSEC);
        }
        return true;
      }

      async waitInitialized() {
        while (this.isInitialized && +(new Date()) - this.locked < this.TIMEOUT_MSEC) {
          await Utl.sleep(this.LOCK_WAIT_MSEC);
        }
        return true;
      }

      genToken() {
        return '' + (+new Date()) + Utl.genPassword(128);
      }

    };

    // テーブル名
    IndexedDB.prototype.STORE_NAME = 'default';

    // ロック待ちミリ秒（1回あたり）
    IndexedDB.prototype.LOCK_WAIT_MSEC = 50;

    // タイムアウトにするミリ秒
    IndexedDB.prototype.TIMEOUT_MSEC = 5000;

    return IndexedDB;

  }).call(this);

  return Utl;

}).call(this);
