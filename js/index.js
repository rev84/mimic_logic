// Generated by CoffeeScript 2.3.1
var ImageFile, ImageFileMimicLogic, changeCond2, checkMimic, clear, compareIndexes, cond2cond1, condId2Text, debug, downDementionStat, genPattern, getCellNum, getColorIndexes, getColorNearIndexes, getConfirmTypes, getLineIndexes, getMimicIndexes, getMimicNearIndexes, getNearIndexes, getNumCommodity, getNumEquip, getNumMad, getNumMimicMax, getNumMimicMin, getNumMoney, getPatternMad, getTd, getValidPatterns, getX, getY, init, initImage, isContainColorNearMimic, isContainType, isContainTypeCount, isItemDetail, isMimicNearly, isNotContainType, isValidPattern, judge, mustConsiderType, onPasteImage, parseImage, parseImageDebug, putCanvas, reset, statValidPatterns, viewDetail, viewTitle;

debug = function() {
  var color, colors, cond, conds, index, j, l, len, len1, len2, o, results1;
  conds = [810, 920, 920, 710, 1020, 920];
  colors = [1, 1, 1, 1, 1, 1];
  $('#num_x').val(3);
  $('#num_y').val(2);
  reset();
  $('#num_mimic_min').val(1);
  $('#num_mimic_max').val(1);
  $('#num_mad').val(1);
  $('#item_detail_on').prop('checked', false);
  $('#num_money').val(0);
  $('#num_equip').val(0);
  $('#num_commodity').val(0);
  for (index = j = 0, len = colors.length; j < len; index = ++j) {
    color = colors[index];
    $('select.box').eq(index).selectpicker('val', color);
  }
  for (index = l = 0, len1 = conds.length; l < len1; index = ++l) {
    cond = conds[index];
    $('.cond1').eq(index).val(cond2cond1(cond));
  }
  $('.cond1').each(function() {
    return changeCond2.bind(this)();
  });
  results1 = [];
  for (index = o = 0, len2 = conds.length; o < len2; index = ++o) {
    cond = conds[index];
    results1.push($('.cond2').eq(index).val(cond));
  }
  return results1;
};

putCanvas = function(w, h) {
  var canvas, debug_image_paste;
  debug_image_paste = document.getElementById('debug_image_paste');
  canvas = document.createElement('canvas');
  [canvas.width, canvas.height] = [w, h];
  debug_image_paste.appendChild(canvas);
  return [canvas, canvas.getContext('2d')];
};

parseImageDebug = function(base64) {
  var callback, img;
  img = new ImageFileMimicLogic(base64);
  callback = function() {
    var canvas, classes, condIndex, ctx, h, html, imageFile, index, j, l, leftups, len, matchRates, obj, rate, ref, ref1, targetImageFile, tb, tr, w, x, y;
    if (!img.isLoaded()) {
      setTimeout(callback, 1000);
      return;
    }
    leftups = img.getLeftUpPoint();
    console.log('leftups:', leftups);
    for (j = 0, len = leftups.length; j < len; j++) {
      [x, y, w, h] = leftups[j];
      [canvas, ctx] = putCanvas(w, h);
      ctx.drawImage(img.canvas, x, y, w, h, 0, 0, w, h);
      imageFile = new ImageFileMimicLogic(canvas, ImageFileMimicLogic.MODE.IMAGE);
      $('#debug_image_paste').append($('<img>').attr('src', imageFile.getBase64BinarizeCond()));
      matchRates = [];
      ref = window.COND_IMAGE_FILES;
      for (condIndex in ref) {
        targetImageFile = ref[condIndex];
        if (targetImageFile === null) {
          continue;
        }
        matchRates.push([condIndex, imageFile.getMatchRate(targetImageFile)]);
      }
      matchRates.sort(function(a, b) {
        return b[1] - a[1];
      });
      //console.log 'matchRates:', matchRates
      html = '<table class="table table-bordered">';
      for (index = l = 0; l < 5; index = ++l) {
        [condIndex, rate] = matchRates[index];
        classes = [];
        if (rate > 0.995 && index === 0) {
          classes.push('confirm');
        }
        html += '<tr class="' + classes.join(' ') + '">';
        html += '<th>' + condId2Text(condIndex) + '</th>';
        html += '<td>' + condIndex + '</td>';
        html += '<td class="right">' + rate + '</td>';
        if (window.COND2IMAGE_FILE[condIndex]) {
          html += '<td><img src="' + window.COND_IMAGE_FILES[condIndex].getBase64BinarizeCond() + '"></td>';
        }
        html += '</tr>';
      }
      $('#debug_image_paste').append($('<p>').html(html));
    }
    // ないやつを出す
    $('#debug_image_paste').append($('<h2>').html('まだないやつ'));
    tb = $('<table>');
    ref1 = window.COND_IMAGE_FILES;
    for (index in ref1) {
      obj = ref1[index];
      if (obj === null) {
        tr = $('<tr>');
        tr.append($('<td>').html(index));
        tr.append($('<td>').html(condId2Text(index)));
        tb.append(tr);
      }
    }
    return $('#debug_image_paste').append(tb);
  };
  return setTimeout(callback, 1000);
};

ImageFile = (function() {
  class ImageFile {
    constructor(base64OrImageOrCanvas, mode = this.MODE.BASE64) {
      var img;
      this.ctx = null;
      switch (mode) {
        case this.MODE.BASE64:
          this.loaded = false;
          img = new Image();
          img.onload = (e) => {
            this.canvas = document.createElement('canvas');
            [this.canvas.width, this.canvas.height] = [img.width, img.height];
            this.ctx = this.canvas.getContext('2d');
            this.ctx.drawImage(img, 0, 0);
            return this.loaded = true;
          };
          img.src = base64OrImageOrCanvas;
          break;
        case this.MODE.IMAGE:
          this.canvas = document.createElement('canvas');
          [this.canvas.width, this.canvas.height] = [base64OrImageOrCanvas.width, base64OrImageOrCanvas.height];
          this.ctx = this.canvas.getContext('2d');
          this.ctx.drawImage(base64OrImageOrCanvas, 0, 0);
          this.loaded = true;
          break;
        case this.MODE.CANVAS:
          this.canvas = base64OrImageOrCanvas;
          this.ctx = this.canvas.getContext('2d');
          this.loaded = true;
      }
    }

    binarize(x = 0, y = 0, w = this.getWidth(), h = this.getHeight(), rgbFilters = []) {
      var filterOk, j, key, l, len, o, ref, ref1, rgb, rgbFilter, val;
      rgb = this.getRgb(x, y, w, h);
      for (x = j = 0, ref = rgb.length; (0 <= ref ? j < ref : j > ref); x = 0 <= ref ? ++j : --j) {
        for (y = l = 0, ref1 = rgb[x].length; (0 <= ref1 ? l < ref1 : l > ref1); y = 0 <= ref1 ? ++l : --l) {
          // フィルタ
          filterOk = true;
          for (o = 0, len = rgbFilters.length; o < len; o++) {
            rgbFilter = rgbFilters[o];
            filterOk = true;
            for (key in rgbFilter) {
              val = rgbFilter[key];
              if (val !== null) {
                if ((val.min != null) && rgb[x][y][key] < val.min) {
                  filterOk = false;
                  break;
                }
                if ((val.max != null) && val.max < rgb[x][y][key]) {
                  filterOk = false;
                  break;
                }
              }
            }
            if (filterOk) {
              break;
            }
          }
          rgb[x][y] = filterOk;
        }
      }
      return rgb;
    }

    getRgb(x = 0, y = 0, w = this.getWidth(), h = this.getHeight()) {
      var colorIndex, dotIndex, imagedata, index, j, len, ref, res, val, xIndex, yIndex;
      res = [];
      imagedata = this.ctx.getImageData(x, y, w, h);
      ref = imagedata.data;
      for (index = j = 0, len = ref.length; j < len; index = ++j) {
        val = ref[index];
        dotIndex = Math.floor(index / 4);
        colorIndex = index % 4;
        xIndex = dotIndex % w;
        yIndex = Math.floor(dotIndex / w);
        if (res[xIndex] == null) {
          res[xIndex] = [];
        }
        if (res[xIndex][yIndex] == null) {
          res[xIndex][yIndex] = {};
        }
        switch (colorIndex) {
          case 0:
            res[xIndex][yIndex].r = val;
            break;
          case 1:
            res[xIndex][yIndex].g = val;
            break;
          case 2:
            res[xIndex][yIndex].b = val;
            break;
          case 3:
            res[xIndex][yIndex].a = val;
        }
      }
      return res;
    }

    getWidth() {
      return this.canvas.width;
    }

    getHeight() {
      return this.canvas.height;
    }

    isLoaded() {
      return this.loaded;
    }

  };

  ImageFile.MODE = {
    BASE64: 0,
    IMAGE: 1,
    CANVAS: 2
  };

  ImageFile.prototype.MODE = {
    BASE64: 0,
    IMAGE: 1,
    CANVAS: 2
  };

  return ImageFile;

}).call(this);

ImageFileMimicLogic = class ImageFileMimicLogic extends ImageFile {
  // 一致率を取得
  getMatchRate(imageFileMimicLogic) {
    var aBinary, bBinary, j, l, ref, ref1, ref2, ref3, score, x, y;
    if (!((imageFileMimicLogic.getWidth() - 1 <= (ref = this.getWidth()) && ref <= imageFileMimicLogic.getWidth() + 1))) {
      // 横幅が合わない
      return 0;
    }
    if (!((imageFileMimicLogic.getHeight() - 1 <= (ref1 = this.getHeight()) && ref1 <= imageFileMimicLogic.getHeight() + 1))) {
      // 縦幅が合わない
      return 0;
    }
    // 検索
    aBinary = imageFileMimicLogic.getMyBinarizeCond();
    bBinary = this.getMyBinarizeCond();
    score = 0;
    for (x = j = 0, ref2 = aBinary.length; (0 <= ref2 ? j < ref2 : j > ref2); x = 0 <= ref2 ? ++j : --j) {
      for (y = l = 0, ref3 = aBinary[x].length; (0 <= ref3 ? l < ref3 : l > ref3); y = 0 <= ref3 ? ++l : --l) {
        if (!((bBinary[x] != null) && (bBinary[x][y] != null))) {
          continue;
        }
        if (!(aBinary[x][y] ^ bBinary[x][y])) {
          score++;
        }
      }
    }
    return score / (imageFileMimicLogic.getWidth() * imageFileMimicLogic.getHeight());
  }

  getBase64Binarize(binary) {
    var canvas, ctx, j, l, ref, ref1, x, y;
    canvas = document.createElement('canvas');
    ctx = canvas.getContext('2d');
    [canvas.width, canvas.height] = [this.getWidth(), this.getHeight()];
    ctx.fillStyle = '#aaaaaa';
    ctx.fillRect(0, 0, this.getWidth(), this.getHeight());
    ctx.fillStyle = '#000000';
    for (x = j = 0, ref = binary.length; (0 <= ref ? j < ref : j > ref); x = 0 <= ref ? ++j : --j) {
      for (y = l = 0, ref1 = binary[x].length; (0 <= ref1 ? l < ref1 : l > ref1); y = 0 <= ref1 ? ++l : --l) {
        if (binary[x][y]) {
          ctx.fillRect(x, y, 1, 1);
        }
      }
    }
    return canvas.toDataURL();
  }

  getBase64BinarizeBorder() {
    return this.getBase64Binarize(this.getMyBinarizeBorder());
  }

  getBase64BinarizeCond() {
    return this.getBase64Binarize(this.getMyBinarizeCond());
  }

  // 枠線を探す2値化をキャッシュ
  getMyBinarizeBorder() {
    if (this.myBinarizeBorder == null) {
      this.myBinarizeBorder = this.binarize(0, 0, void 0, void 0, [
        {
          r: {
            min: 190
          },
          g: {
            min: 190
          },
          b: {
            min: 190
          }
        }
      ]);
    }
    return this.myBinarizeBorder;
  }

  // 条件としての一致の2値化をキャッシュ
  getMyBinarizeCond() {
    if (this.myBinarizeCond == null) {
      this.myBinarizeCond = this.binarize(0, 0, void 0, void 0, [
        {
          // 白文字
          r: {
            min: 75
          },
          g: {
            min: 75
          },
          b: {
            min: 75
          }
        },
        {
          // 赤文字
          r: {
            min: 90
          },
          g: {
            max: 150
          },
          b: {
            max: 150
          }
        },
        {
          // 青文字
          r: {
            max: 100
          },
          g: {
            max: 200
          },
          b: {
            min: 90
          }
        }
      ]);
    }
    return this.myBinarizeCond;
  }

  // 宝箱の位置検出
  getTreasureboxPoints(treasureboxImageFiles) {
    var SCORE_LIMIT, baseRgb, baseX, baseY, color, hField, imageFile, j, key, l, len, o, q, r, ref, ref1, ref2, ref3, rgb, score, scores, treasureboxes, wField, x, xs, y, ys;
    baseRgb = this.getRgb();
    treasureboxes = [];
    scores = [];
//scores = Utl.array2dFill baseRgb.length, baseRgb[0].length, 0
    for (key in treasureboxImageFiles) {
      imageFile = treasureboxImageFiles[key];
      SCORE_LIMIT = (imageFile.getWidth() * imageFile.getHeight() * 255 * 3) * 0.075; // このスコア以上行った時点で探索打ち切り
      rgb = imageFile.getRgb();
      for (baseX = j = 0, ref = baseRgb.length; (0 <= ref ? j < ref : j > ref); baseX = 0 <= ref ? ++j : --j) {
        if (baseRgb.length <= baseX + imageFile.getWidth()) {
          continue;
        }
        for (baseY = l = 0, ref1 = baseRgb[baseX].length; (0 <= ref1 ? l < ref1 : l > ref1); baseY = 0 <= ref1 ? ++l : --l) {
          if (baseRgb[baseX].length <= baseY + imageFile.getHeight()) {
            continue;
          }
          score = 0;
          for (x = o = 0, ref2 = rgb.length; (0 <= ref2 ? o < ref2 : o > ref2); x = 0 <= ref2 ? ++o : --o) {
            for (y = q = 0, ref3 = rgb[x].length; (0 <= ref3 ? q < ref3 : q > ref3); y = 0 <= ref3 ? ++q : --q) {
              score += Math.abs(baseRgb[baseX + x][baseY + y].r - rgb[x][y].r);
              score += Math.abs(baseRgb[baseX + x][baseY + y].g - rgb[x][y].g);
              score += Math.abs(baseRgb[baseX + x][baseY + y].b - rgb[x][y].b);
            }
            // 行き過ぎなので打ち切り
            if (SCORE_LIMIT < score) {
              score = Number.MAX_SAFE_INTEGER;
              break;
            }
          }
          // スコアがしきい値以内なので追加
          if (score <= SCORE_LIMIT) {
            scores.push([baseX, baseY, window.COLORS[key], score]);
          }
        }
      }
    }
    //console.log 'SCORE_LIMIT:',SCORE_LIMIT
    //scores[baseX][baseY] = [baseX, baseY, key, score]

    // このソートでindexに対応
    scores.sort(function(a, b) {
      y = a[1] - b[1];
      if (y !== 0) {
        return y;
      }
      return a[0] - b[0];
    });
    // フィールドの横・縦幅を取得
    xs = [];
    ys = [];
    for (r = 0, len = scores.length; r < len; r++) {
      [x, y, color, score] = scores[r];
      if (!Utl.inArray(x, xs)) {
        xs.push(x);
      }
      if (!Utl.inArray(y, ys)) {
        ys.push(y);
      }
    }
    wField = xs.length;
    hField = ys.length;
    console.log('scores:', scores);
    return [scores, wField, hField];
  }

  // 吹き出しの左上の座標を取得
  getLeftUpPoint() {
    var COUNT_MIN, MARGIN_WIDTH, baseCount, baseIndex, baseX, baseY, colorId, count, decidedIndex, decidedIndexes, hField, inArrayNear, isDecided, isWhite, j, l, len, len1, myBinaryBorder, nearScores, nearestIndex, o, q, r, ref, ref1, ref2, ref3, ref4, ref5, resultIndex, results, s, startPoints, t, targetCount, targetIndex, targetX, targetY, treasureIndex, treasurePoints, treasureX, treasureY, usedStartPoints, wField, x, xStart, y;
    // 横棒と認識する最低の長さ
    COUNT_MIN = 20;
    // 吹き出しの丸い部分の横幅
    MARGIN_WIDTH = 8;
    myBinaryBorder = this.getMyBinarizeBorder();
    // aryに隣接セルが含まれているか
    inArrayNear = function(x, y, ary) {
      var j, len, xAry, yAry;
      for (j = 0, len = ary.length; j < len; j++) {
        [xAry, yAry] = ary[j];
        if ((x - 1 <= xAry && xAry <= x + 1) && (y - 1 <= yAry && yAry <= y + 1)) {
          return true;
        }
      }
      return false;
    };
    //###########
    // 横棒の検出
    //###########
    startPoints = [];
    for (y = j = 0, ref = this.getHeight(); (0 <= ref ? j < ref : j > ref); y = 0 <= ref ? ++j : --j) {
      xStart = null;
      count = 0;
      for (x = l = 0, ref1 = this.getWidth(); (0 <= ref1 ? l < ref1 : l > ref1); x = 0 <= ref1 ? ++l : --l) {
        isWhite = myBinaryBorder[x][y];
        if (isWhite) {
          if (xStart === null) {
            xStart = x;
            count = 1;
          } else {
            count++;
          }
        } else {
          if (xStart !== null) {
            if (count >= COUNT_MIN) {
              if (!inArrayNear(xStart, y, startPoints)) {
                startPoints.push([xStart, y, count]);
              }
            }
          }
          xStart = null;
          count = 0;
        }
      }
      if (count >= COUNT_MIN) {
        if (!inArrayNear(xStart, y, startPoints)) {
          startPoints.push([xStart, y, count]);
        }
      }
    }
    startPoints.sort(function(a, b) {
      var cond1;
      cond1 = a[1] - b[1];
      if (cond1 !== 0) {
        return cond1;
      }
      return a[0] - b[0];
    });
    //console.log 'startPoints:', startPoints

    // startPointsを2つずつ選んで組をつくる
    results = [];
    usedStartPoints = Utl.arrayFill(startPoints.length, false);
    for (baseIndex = o = 0, ref2 = startPoints.length; (0 <= ref2 ? o < ref2 : o > ref2); baseIndex = 0 <= ref2 ? ++o : --o) {
      [baseX, baseY, baseCount] = startPoints[baseIndex];
      if (usedStartPoints[baseIndex]) {
        continue;
      }
      for (targetIndex = q = ref3 = baseIndex + 1, ref4 = startPoints.length; (ref3 <= ref4 ? q < ref4 : q > ref4); targetIndex = ref3 <= ref4 ? ++q : --q) {
        [targetX, targetY, targetCount] = startPoints[targetIndex];
        if (usedStartPoints[targetIndex]) {
          continue;
        }
        if ((baseX - 2 <= targetX && targetX <= baseX + 2) && baseY < targetY) {
          results.push({
            x: baseX - MARGIN_WIDTH,
            y: baseY,
            w: baseCount + MARGIN_WIDTH * 2,
            h: targetY - baseY,
            index: 0
          });
          usedStartPoints[baseIndex] = usedStartPoints[targetIndex] = true;
          break;
        }
      }
    }
    // 宝箱の位置検出
    [treasurePoints, wField, hField] = this.getTreasureboxPoints(window.TREASUREBOX_IMAGE_FILES);
    // 宝箱の情報から、吹き出しのインデックスを特定
    decidedIndexes = Utl.arrayFill(results.length, false);
    for (treasureIndex = r = 0, len = treasurePoints.length; r < len; treasureIndex = ++r) {
      [treasureX, treasureY, colorId] = treasurePoints[treasureIndex];
      nearScores = [];
      for (decidedIndex = s = 0, ref5 = decidedIndexes.length; (0 <= ref5 ? s < ref5 : s > ref5); decidedIndex = 0 <= ref5 ? ++s : --s) {
        nearScores[decidedIndex] = {
          index: decidedIndex,
          score: Number.MAX_SAFE_INTEGER
        };
      }
      for (resultIndex = t = 0, len1 = decidedIndexes.length; t < len1; resultIndex = ++t) {
        isDecided = decidedIndexes[resultIndex];
        if (isDecided) {
          // もう決定済み
          continue;
        }
        if (treasureX < results[resultIndex].x || treasureY < results[resultIndex].y) {
          // 宝箱より右や下の吹き出しはありえない
          continue;
        }
        nearScores[resultIndex].score = Math.abs(treasureX - results[resultIndex].x) + Math.abs(treasureY - results[resultIndex].y);
      }
      // ソートして一番距離が短いもの
      nearScores.sort(function(a, b) {
        return a.score - b.score;
      });
      // これが対応する吹き出しのインデックス
      nearestIndex = nearScores[0].index;
      results[nearestIndex].index = treasureIndex;
      results[nearestIndex].color = colorId;
      decidedIndexes[nearestIndex] = true;
    }
    // 確定したインデックス順に並べ替える
    results.sort(function(a, b) {
      return a.index - b.index;
    });
    return [results, wField, hField];
  }

};

window.CONFIG = {
  FIELD_MIN: 2,
  FIELD_MAX: 3
};

window.CONSTS = {
  NOT_MIMIC: 0,
  MIMIC: 1,
  EQUIP: 2,
  MONEY: 3,
  COMMODITY: 4
};

window.COLORS = {
  RED: 1,
  BLUE: 2,
  BLACK: 3
};

window.DIRECTIONS = {
  UP: 1,
  DOWN: 2,
  LEFT: 3,
  RIGHT: 4
};

window.CONDS = {
  'Zzz...': {
    0: 'Zzz...'
  },
  'ミミック2匹以上が縦か横で隣あった位置に': {
    1100: 'いる',
    1110: 'はいない'
  },
  'ミミック2匹が縦か横で隣あった位置に': {
    1101: 'いる',
    1111: 'はいない'
  },
  '上の宝箱は': {
    710: 'ミミックだ',
    720: 'ミミックじゃない',
    732: '装備品が入っている',
    733: 'お金が入っている',
    734: '消費アイテムが入っている',
    742: '装備品が入っていない',
    743: 'お金が入っていない',
    744: '消費アイテムが入っていない'
  },
  '下の宝箱は': {
    810: 'ミミックだ',
    820: 'ミミックじゃない',
    832: '装備品が入っている',
    833: 'お金が入っている',
    834: '消費アイテムが入っている',
    842: '装備品が入っていない',
    843: 'お金が入っていない',
    844: '消費アイテムが入っていない'
  },
  '左の宝箱は': {
    910: 'ミミックだ',
    920: 'ミミックじゃない',
    932: '装備品が入っている',
    933: 'お金が入っている',
    934: '消費アイテムが入っている',
    942: '装備品が入っていない',
    943: 'お金が入っていない',
    944: '消費アイテムが入っていない'
  },
  '右の宝箱は': {
    1010: 'ミミックだ',
    1020: 'ミミックじゃない',
    1032: '装備品が入っている',
    1033: 'お金が入っている',
    1034: '消費アイテムが入っている',
    1042: '装備品が入っていない',
    1043: 'お金が入っていない',
    1044: '消費アイテムが入っていない'
  },
  '赤い宝箱のなかに': {
    10: 'ミミックがいるよ',
    20: 'ミミックはいないよ'
  },
  '赤い宝箱に': {
    30: 'ミミックは0匹いる',
    31: 'ミミックは1匹いる',
    32: 'ミミックは2匹いる',
    33: 'ミミックは3匹いる',
    34: 'ミミックは4匹いる'
  },
  /*
  35: 'ミミックは5匹いる'
  36: 'ミミックは6匹いる'
  37: 'ミミックは7匹いる'
  38: 'ミミックは8匹いる'
  39: 'ミミックは9匹いる'
  */
  '青い宝箱のなかに': {
    110: 'ミミックがいるよ',
    120: 'ミミックはいないよ'
  },
  '青い宝箱に': {
    130: 'ミミックは0匹いる',
    131: 'ミミックは1匹いる',
    132: 'ミミックは2匹いる',
    133: 'ミミックは3匹いる',
    134: 'ミミックは4匹いる'
  },
  /*
  135: 'ミミックは5匹いる'
  136: 'ミミックは6匹いる'
  137: 'ミミックは7匹いる'
  138: 'ミミックは8匹いる'
  139: 'ミミックは9匹いる'
  */
  '黒い宝箱のなかに': {
    210: 'ミミックがいるよ',
    220: 'ミミックはいないよ'
  },
  '黒い宝箱に': {
    230: 'ミミックは0匹いる',
    231: 'ミミックは1匹いる',
    232: 'ミミックは2匹いる',
    233: 'ミミックは3匹いる',
    234: 'ミミックは4匹いる'
  },
  /*
  235: 'ミミックは5匹いる'
  236: 'ミミックは6匹いる'
  237: 'ミミックは7匹いる'
  238: 'ミミックは8匹いる'
  239: 'ミミックは9匹いる'
  */
  '一番上の列': {
    310: 'にミミックがいるよ',
    320: 'にミミックはいないよ',
    10002: 'のどこかに装備品が入っている',
    10003: 'のどこかにお金が入っている',
    10004: 'のどこかに消費アイテムが入っている',
    10012: 'のどこにも装備品は入っていない',
    10013: 'のどこにもお金は入っていない',
    10014: 'のどこにも消費アイテムは入っていない'
  },
  '一番下の列': {
    410: 'にミミックがいるよ',
    420: 'にミミックはいないよ',
    20002: 'のどこかに装備品が入っている',
    20003: 'のどこかにお金が入っている',
    20004: 'のどこかに消費アイテムが入っている',
    20012: 'のどこにも装備品は入っていない',
    20013: 'のどこにもお金は入っていない',
    20014: 'のどこにも消費アイテムは入っていない'
  },
  '一番左の列': {
    510: 'にミミックがいるよ',
    520: 'にミミックはいないよ',
    30002: 'のどこかに装備品が入っている',
    30003: 'のどこかにお金が入っている',
    30004: 'のどこかに消費アイテムが入っている',
    30012: 'のどこにも装備品は入っていない',
    30013: 'のどこにもお金は入っていない',
    30014: 'のどこにも消費アイテムは入っていない'
  },
  '一番右の列': {
    610: 'にミミックがいるよ',
    620: 'にミミックはいないよ',
    40002: 'のどこかに装備品が入っている',
    40003: 'のどこかにお金が入っている',
    40004: 'のどこかに消費アイテムが入っている',
    40012: 'のどこにも装備品は入っていない',
    40013: 'のどこにもお金は入っていない',
    40014: 'のどこにも消費アイテムは入っていない'
  },
  '上の列と下の列は': {
    1210: '上の方がミミックが多い',
    1220: '下の方がミミックが多い',
    1230: 'ミミックの数は同じ'
  },
  '左の列と右の列は': {
    1310: '左の方がミミックが多い',
    1320: '右の方がミミックが多い',
    1330: 'ミミックの数は同じ'
  },
  '赤宝箱と': {
    /*
    1410: '青宝箱は、赤宝箱の方がミミックが多い'
    1420: '青宝箱は、青宝箱の方がミミックが多い'
    1421: '青宝箱のミミックの数は同じ'
    */
    1430: '黒宝箱は、赤宝箱の方がミミックが多い',
    1440: '黒宝箱は、黒宝箱の方がミミックが多い',
    1441: '黒宝箱のミミックの数は同じ'
  },
  '青宝箱と': {
    1510: '赤宝箱は、青宝箱の方がミミックが多い',
    1520: '赤宝箱は、赤宝箱の方がミミックが多い',
    1521: '赤宝箱のミミックの数は同じ'
  },
  /*
  1530: '黒宝箱は、青宝箱の方がミミックが多い'
  1540: '黒宝箱は、黒宝箱の方がミミックが多い'
  1541: '黒宝箱のミミックの数は同じ'
  */
  /*
  '黒宝箱と':
  1610: '赤宝箱は、黒宝箱の方がミミックが多い'
  1620: '赤宝箱は、赤宝箱の方がミミックが多い'
  1621: '赤宝箱のミミックの数は同じ'
  1630: '青宝箱は、黒宝箱の方がミミックが多い'
  1640: '青宝箱は、青宝箱の方がミミックが多い'
  1641: '青宝箱のミミックの数は同じ'
  */
  '私は': {
    1700: 'ミミックじゃない'
  },
  '赤い宝箱の': {
    //1811: '上にミミックがいる'
    1821: '上にミミックはいない',
    //1812: '下にミミックがいる'
    1822: '下にミミックはいない',
    //1813: '左にミミックがいる'
    1823: '左にミミックはいない',
    //1814: '右にミミックがいる'
    1824: '右にミミックはいない'
  },
  '青い宝箱の': {
    //1911: '上にミミックがいる'
    1921: '上にミミックはいない',
    //1912: '下にミミックがいる'
    1922: '下にミミックはいない',
    //1913: '左にミミックがいる'
    1923: '左にミミックはいない',
    //1914: '右にミミックがいる'
    1924: '右にミミックはいない'
  },
  '黒い宝箱の': {
    //2011: '上にミミックがいる'
    2021: '上にミミックはいない',
    //2012: '下にミミックがいる'
    2022: '下にミミックはいない',
    //2013: '左にミミックがいる'
    2023: '左にミミックはいない',
    //2014: '右にミミックがいる'
    2024: '右にミミックはいない'
  },
  'ミミックの': {
    2111: '上に赤い宝箱がある',
    2211: '上に青い宝箱がある',
    2311: '上に黒い宝箱がある',
    2112: '下に赤い宝箱がある',
    2212: '下に青い宝箱がある',
    2312: '下に黒い宝箱がある',
    2113: '左に赤い宝箱がある',
    2213: '左に青い宝箱がある',
    2313: '左に黒い宝箱がある',
    2114: '右に赤い宝箱がある',
    2214: '右に青い宝箱がある',
    2314: '右に黒い宝箱がある'
  },
  '赤の宝箱のどこかに': {
    3002: '装備品が入っている',
    3003: 'お金が入っている',
    3004: '消費アイテムが入っている'
  },
  '赤の宝箱には': {
    3102: '装備品は入っていない',
    3103: 'お金は入っていない',
    3104: '消費アイテムは入っていない'
  },
  '青の宝箱のどこかに': {
    4002: '装備品が入っている',
    4003: 'お金が入っている',
    4004: '消費アイテムが入っている'
  },
  '青の宝箱には': {
    4102: '装備品は入っていない',
    4103: 'お金は入っていない',
    4104: '消費アイテムは入っていない'
  },
  '黒の宝箱のどこかに': {
    5002: '装備品が入っている',
    5003: 'お金が入っている',
    5004: '消費アイテムが入っている'
  },
  '黒の宝箱には': {
    5102: '装備品は入っていない',
    5103: 'お金は入っていない',
    5104: '消費アイテムは入っていない'
  },
  'この中にミミックは': {
    50001: '1匹いる',
    50002: '2匹いる',
    50003: '3匹いる',
    50004: '4匹いる',
    50005: '5匹いる',
    50006: '6匹いる',
    50007: '7匹いる',
    50008: '8匹いる',
    50009: '9匹いる'
  }
};

window.CACHE = {
  TD_HTML: null
};

window.COND_IMAGE_FILES = {};

window.TREASUREBOX_IMAGE_FILES = {};

window.IS_WAIT = false;

$().ready(function() {
  init();
  initImage();
  return debug();
});

initImage = function() {
  var condIndex, condText, fileName, image, key, onerror, onload, ref, ref1, results1, val;
  onload = function(index, img) {
    return window.COND_IMAGE_FILES[index] = new ImageFileMimicLogic(img, ImageFileMimicLogic.MODE.IMAGE);
  };
  onerror = function(index) {
    return window.COND_IMAGE_FILES[index] = null;
  };
  ref = window.CONDS;
  for (key in ref) {
    val = ref[key];
    for (condIndex in val) {
      condText = val[condIndex];
      image = new Image();
      image.onload = onload.bind(image, condIndex, image);
      image.onerror = onerror.bind(image, condIndex);
      image.src = './image/conds/' + condIndex + '.png';
    }
  }
  onload = function(index, img) {
    return window.TREASUREBOX_IMAGE_FILES[index] = new ImageFileMimicLogic(img, ImageFileMimicLogic.MODE.IMAGE);
  };
  onerror = function(index) {
    return window.TREASUREBOX_IMAGE_FILES[index] = null;
  };
  ref1 = {
    RED: 'red.png',
    BLUE: 'blue.png',
    BLACK: 'black.png'
  };
  results1 = [];
  for (key in ref1) {
    fileName = ref1[key];
    image = new Image();
    image.onload = onload.bind(image, key, image);
    image.onerror = onerror.bind(image, key);
    results1.push(image.src = './image/treasureboxes/' + fileName);
  }
  return results1;
};

onPasteImage = function(e) {
  var clipboardData, fr, imageFile, index, indexOfFiles, j, len, ref, type;
  // ブラウザによる貼り付けは無効
  e.preventDefault();
  console.log('画像貼付:', e);
  clipboardData = e.originalEvent.clipboardData;
  if (!clipboardData) {
    return true;
  }
  if (!clipboardData.types) {
    return true;
  }
  indexOfFiles = false;
  ref = clipboardData.types;
  for (index = j = 0, len = ref.length; j < len; index = ++j) {
    type = ref[index];
    if (type === 'Files') {
      indexOfFiles = index;
      break;
    }
  }
  if (indexOfFiles === false) {
    return true;
  }
  imageFile = clipboardData.items[indexOfFiles].getAsFile();
  fr = new FileReader;
  fr.onload = function(e) {
    var base64;
    base64 = e.target.result;
    return window.parseImage(base64);
  };
  //window.parseImageDebug base64
  fr.readAsDataURL(imageFile);
  return true;
};

parseImage = function(base64) {
  var callback, img;
  img = new ImageFileMimicLogic(base64);
  callback = function() {
    var canvas, cond, condIndex, hField, imageFile, j, len, matchRates, mimicMad, mimicMax, mimicMin, point, pointIndex, points, ref, targetImageFile, wField;
    if (!img.isLoaded()) {
      setTimeout(callback, 100);
      return;
    }
    window.IS_WAIT = true;
    [points, wField, hField] = img.getLeftUpPoint();
    console.log('points:', points);
    mimicMin = $('#num_mimic_min').val();
    mimicMax = $('#num_mimic_max').val();
    mimicMad = $('#num_mad').val();
    $('#num_x').val(wField);
    $('#num_y').val(hField);
    reset();
    $('#num_mimic_min').val(mimicMin);
    $('#num_mimic_max').val(mimicMax);
    $('#num_mad').val(mimicMad);
    for (pointIndex = j = 0, len = points.length; j < len; pointIndex = ++j) {
      point = points[pointIndex];
      // 吹き出し領域のキャンバス
      canvas = document.createElement('canvas');
      [canvas.width, canvas.height] = [point.w, point.h];
      canvas.getContext('2d').drawImage(img.canvas, point.x, point.y, point.w, point.h, 0, 0, point.w, point.h);
      imageFile = new ImageFileMimicLogic(canvas, ImageFileMimicLogic.MODE.CANVAS);
      // 比較
      matchRates = [];
      ref = window.COND_IMAGE_FILES;
      for (condIndex in ref) {
        targetImageFile = ref[condIndex];
        if (targetImageFile === null) {
          continue;
        }
        matchRates.push([condIndex, imageFile.getMatchRate(targetImageFile)]);
      }
      matchRates.sort(function(a, b) {
        return b[1] - a[1];
      });
      console.log('matchRates[' + pointIndex + ']', matchRates);
      // 条件文はこれ
      cond = matchRates[0][0];
      $('.cond1').eq(point.index).val(cond2cond1(cond));
      changeCond2.bind($('.cond1').eq(point.index))();
      $('.cond2').eq(point.index).val(cond);
      // 色
      $('select.box').eq(point.index).selectpicker('val', point.color);
      window.IS_WAIT = false;
    }
    console.log('finished.parseImage');
    return judge();
  };
  return setTimeout(callback, 100);
};

cond2cond1 = function(cond) {
  var cond1, cond2japanese, id, obj, ref;
  ref = window.CONDS;
  for (cond1 in ref) {
    obj = ref[cond1];
    for (id in obj) {
      cond2japanese = obj[id];
      if (Number(id) === Number(cond)) {
        return cond1;
      }
    }
  }
  return null;
};

init = function() {
  var index, j, ref, ref1;
  $(':checkbox').radiocheck();
  $('#image_paste').on('paste', onPasteImage);
  $('#item_detail_on').on('change', viewDetail);
  $('#num_x, #num_y').html('');
  for (index = j = ref = window.CONFIG.FIELD_MIN, ref1 = window.CONFIG.FIELD_MAX; (ref <= ref1 ? j <= ref1 : j >= ref1); index = ref <= ref1 ? ++j : --j) {
    $('#num_x, #num_y').append($('<option>').attr('value', index).html(index));
  }
  $('#num_x, #num_y').val(2);
  $('#num_x, #num_y').on('change', reset);
  $('#judge').on('click', judge);
  $('#clear').on('click', clear);
  $('#num_mimic_min, #num_mimic_max, #num_mad, #num_money, #num_equip, #num_commodity').on('change', judge);
  reset();
  return viewDetail();
};

viewDetail = function() {
  if (isItemDetail()) {
    return $('#item_detail').removeClass('no_display');
  } else {
    return $('#item_detail').addClass('no_display');
  }
};

clear = function() {
  var numMad, numMimicMax, numMimicMin;
  numMimicMin = $('#num_mimic_min').val();
  numMimicMax = $('#num_mimic_max').val();
  numMad = $('#num_mad').val();
  reset();
  $('#num_mimic_min').val(numMimicMin);
  $('#num_mimic_max').val(numMimicMax);
  return $('#num_mad').val(numMad);
};

reset = function() {
  var cellNum, index, j, l, ref, ref1, tr, x, xIndex, y, yIndex;
  x = getX();
  y = getY();
  cellNum = getCellNum();
  $('#num_mimic_min, #num_mimic_max, #num_mad, #num_money, #num_equip, #num_commodity').html('');
  $('#field tbody').html('');
  for (yIndex = j = 0, ref = y; (0 <= ref ? j < ref : j > ref); yIndex = 0 <= ref ? ++j : --j) {
    tr = $('<tr>');
    for (xIndex = l = 0, ref1 = x; (0 <= ref1 ? l < ref1 : l > ref1); xIndex = 0 <= ref1 ? ++l : --l) {
      index = yIndex * x + xIndex;
      tr.append(getTd(index));
      $('#num_mimic_min, #num_mimic_max, #num_mad, #num_money, #num_equip, #num_commodity').append($('<option>').html(index).attr('value', index));
    }
    $('#field tbody').append(tr);
  }
  $('#field tbody').find('.box').selectpicker({
    noneSelectedText: '',
    width: 'fit'
  });
  return $('#num_mimic_min, #num_mimic_max, #num_mad, #num_money, #num_equip, #num_commodity').append($('<option>').html(cellNum).attr('value', cellNum));
};

getTd = function(index) {
  var j, len, obj, op, options, ref, td, title;
  if (window.CACHE.TD_HTML === null) {
    window.CACHE.TD_HTML = $('#cell_sample').html();
  }
  td = $('<td>').html(window.CACHE.TD_HTML).addClass('cell center').attr('data-index', index);
  td.find('.cond1, .cond2').html('');
  td.find('.cond1').append($('<option>').html('').attr('value', 0));
  td.find('.cond2').on('change', judge);
  options = [];
  ref = window.CONDS;
  for (title in ref) {
    obj = ref[title];
    options.push($('<option>').html(title));
  }
  options.sort(function(a, b) {
    if (a.text() < b.text()) {
      return -1;
    }
    if (a.text() > b.text()) {
      return 1;
    }
    return 0;
  });
  for (j = 0, len = options.length; j < len; j++) {
    op = options[j];
    td.find('.cond1').append(op);
  }
  td.find('.cond1').on('change', changeCond2);
  return td;
};

changeCond2 = function() {
  var cond1, cond2, condId, j, len, op, options, ref, results1, text;
  cond1 = $(this).val();
  cond2 = $(this).parent().find('.cond2');
  cond2.html('').append($('<option>').html('').attr('value', 0));
  options = [];
  ref = window.CONDS[cond1];
  for (condId in ref) {
    text = ref[condId];
    options.push($('<option>').html(text).attr('value', condId));
  }
  options.sort(function(a, b) {
    if (a.text() < b.text()) {
      return -1;
    }
    if (a.text() > b.text()) {
      return 1;
    }
    return 0;
  });
  results1 = [];
  for (j = 0, len = options.length; j < len; j++) {
    op = options[j];
    results1.push(cond2.append(op));
  }
  return results1;
};

judge = function() {
  var allowed, cellNum, colors, conds, condsIndex, condsLight, confirms, dummy, index, j, kakuteiTypes, key, l, len, len1, len2, len3, madPattern, madPatternOnlyMimicResearch, numCommodity, numEquip, numMad, numMimic, numMimicMax, numMimicMin, numMoney, nums, o, patterns, q, r, ref, ref1, ref2, ref3, ref4, ref5, ref6, s, stockedIndexes, t, typeConst, u, val, validOnlyMimicResearch, validPattern, validPatternOnlyMimicResearch, valids, validsOnlyMimicResearch, value, x, y, z;
  if (window.IS_WAIT) {
    return;
  }
  viewTitle(null);
  x = getX();
  y = getY();
  cellNum = getCellNum();
  numMimicMin = getNumMimicMin();
  numMimicMax = getNumMimicMax();
  numMad = getNumMad();
  numMoney = getNumMoney();
  numEquip = getNumEquip();
  numCommodity = getNumCommodity();
  nums = {};
  nums[window.CONSTS.MIMIC] = [numMimicMin, numMimicMax];
  nums[window.CONSTS.EQUIP] = numEquip;
  nums[window.CONSTS.MONEY] = numMoney;
  nums[window.CONSTS.COMMODITY] = numCommodity;
  conds = Utl.arrayFill(getCellNum());
  colors = Utl.arrayFill(getCellNum());
  $('.cell').each(function() {
    var box, cond, index;
    index = Number($(this).attr('data-index'));
    box = Number($(this).find('select.box').eq(0).val());
    box = Utl.inArray(box, [window.COLORS.RED, window.COLORS.BLUE, window.COLORS.BLACK]) ? box : window.COLORS.RED;
    cond = Number($(this).find('.cond2').eq(0).val());
    conds[index] = cond;
    return colors[index] = box;
  });
  // インデックス一覧
  stockedIndexes = {
    COLOR: getColorIndexes(colors), // 色ごと
    LINE: getLineIndexes(colors, x, y), // 列ごと
    NEAR: getNearIndexes(colors, x, y), // 自身の隣
    COLOR_NEAR: getColorNearIndexes(colors, x, y) // 色の隣
  };
  console.log('conds:', conds);
  console.log('colors:', colors);
  console.log('stockedIndexes', stockedIndexes);
  // まずはミミックだけを仮定する
  condsLight = Utl.clone(conds);
// 条件を緩める
  for (condsIndex = j = 0, ref = condsLight.length; (0 <= ref ? j < ref : j > ref); condsIndex = 0 <= ref ? ++j : --j) {
    if (mustConsiderType([condsLight[condsIndex]])) {
      condsLight[condsIndex] = 0;
    }
  }
  // 確定パターン取得
  confirms = getConfirmTypes(true);
  for (index = l = 0, len = confirms.length; l < len; index = ++l) {
    value = confirms[index];
    if (value !== null && value !== 0) {
      confirms[index] = [value];
    } else {
      confirms[index] = null;
    }
  }
  patterns = [];
  for (numMimic = o = ref1 = numMimicMin, ref2 = numMimicMax; (ref1 <= ref2 ? o <= ref2 : o >= ref2); numMimic = ref1 <= ref2 ? ++o : --o) {
    patterns = patterns.concat(genPattern([cellNum - numMimic, numMimic, 0, 0, 0], confirms));
  }
  validsOnlyMimicResearch = getValidPatterns(condsLight, colors, stockedIndexes, patterns, nums, numMad);
  [validPatternOnlyMimicResearch, madPatternOnlyMimicResearch] = statValidPatterns(validsOnlyMimicResearch);
  console.log('validsOnlyMimicResearch, validPatternOnlyMimicResearch, madPatternOnlyMimicResearch', validsOnlyMimicResearch, validPatternOnlyMimicResearch, madPatternOnlyMimicResearch);
  // アイテム種別を考慮する必要がないか、この時点でミミックが確定できていれば終了
  if (!isItemDetail() || !mustConsiderType(conds) || checkMimic(validPatternOnlyMimicResearch, numMimic)) {
    console.log('finished.1.');
    return viewTitle(validPatternOnlyMimicResearch, madPatternOnlyMimicResearch);
  }
  // より詳細に見る
  // ありえるtypeCostを作る
  confirms = getConfirmTypes(false);
  allowed = Utl.arrayFill(confirms.length, []);
  kakuteiTypes = [];
  ref3 = window.CONSTS;
  for (val in ref3) {
    key = ref3[val];
    kakuteiTypes[val] = 0;
  }
  for (index = q = 0, len1 = allowed.length; q < len1; index = ++q) {
    dummy = allowed[index];
    // 規定されてる
    if (confirms[index] !== 0 && confirms[index] !== null) {
      allowed[index].push(confirms[index]);
      kakuteiTypes[confirms[index]]++;
    } else {
      // 先の結果から分かる
      if (Utl.inArray(window.CONSTS.MIMIC, validPatternOnlyMimicResearch[index])) {
        allowed[index].push(window.CONSTS.MIMIC);
      }
      if (Utl.inArray(window.CONSTS.NOT_MIMIC, validPatternOnlyMimicResearch[index])) {
        allowed[index].push(window.CONSTS.EQUIP, window.CONSTS.MONEY, window.CONSTS.COMMODITY);
      }
    }
  }
  valids = [];
  for (r = 0, len2 = validsOnlyMimicResearch.length; r < len2; r++) {
    validOnlyMimicResearch = validsOnlyMimicResearch[r];
    numMimic = 0;
    for (s = 0, len3 = validOnlyMimicResearch.length; s < len3; s++) {
      typeConst = validOnlyMimicResearch[s];
      if (typeConst === window.CONSTS.MIMIC) {
        numMimic++;
      }
    }
    // アイテム詳細の指定があるので決め打ち
    if (isItemDetail()) {
      patterns = genPattern([0, numMimic, numEquip, numMoney, numCommodity], allowed);
      nums = {};
      nums[window.CONSTS.MIMIC] = [numMimic, numMimic];
      nums[window.CONSTS.EQUIP] = numEquip;
      nums[window.CONSTS.MONEY] = numMoney;
      nums[window.CONSTS.COMMODITY] = numCommodity;
      valids = valids.concat(getValidPatterns(conds, colors, stockedIndexes, patterns, nums, numMad));
    } else {

// アイテム詳細の指定がない場合は全パターン
      for (numEquip = t = 0, ref4 = cellNum - numMimic; (0 <= ref4 ? t <= ref4 : t >= ref4); numEquip = 0 <= ref4 ? ++t : --t) {
        if (numEquip < kakuteiTypes[window.CONSTS.EQUIP]) {
          continue;
        }
        for (numMoney = u = 0, ref5 = cellNum - numMimic; (0 <= ref5 ? u <= ref5 : u >= ref5); numMoney = 0 <= ref5 ? ++u : --u) {
          if (numMoney < kakuteiTypes[window.CONSTS.MONEY]) {
            continue;
          }
          for (numCommodity = z = 0, ref6 = cellNum - numMimic; (0 <= ref6 ? z <= ref6 : z >= ref6); numCommodity = 0 <= ref6 ? ++z : --z) {
            if (numCommodity < kakuteiTypes[window.CONSTS.COMMODITY]) {
              continue;
            }
            if ((numMimic + numEquip + numMoney + numCommodity) !== cellNum) {
              continue;
            }
            patterns = genPattern([0, numMimic, numEquip, numMoney, numCommodity], allowed);
            nums = {};
            nums[window.CONSTS.MIMIC] = [numMimic, numMimic];
            nums[window.CONSTS.EQUIP] = numEquip;
            nums[window.CONSTS.MONEY] = numMoney;
            nums[window.CONSTS.COMMODITY] = numCommodity;
            valids = valids.concat(getValidPatterns(conds, colors, stockedIndexes, patterns, nums, numMad));
          }
        }
      }
    }
  }
  [validPattern, madPattern] = statValidPatterns(valids);
  console.log('valids, validPattern, madPattern', valids, validPattern, madPattern);
  // 全探索したので最終回答
  viewTitle(validPattern);
  if (validPattern === null) {
    window.alert('条件を満たすパターンがありません');
  }
  return console.log('finished.2.');
};

viewTitle = function(views = null, mads = null) {
  var className, html, index, j, l, len, len1, madArray, results1, typeConsts;
  $('td, .title, .title_mad').removeClass('not_mimic mimic money equip commodity unknown');
  $('.title, .title_mad').html('');
  if (views === null) {
    return;
  }
  for (index = j = 0, len = views.length; j < len; index = ++j) {
    typeConsts = views[index];
    [className, html] = (function() {
      if (typeConsts.length > 1) {
        if (Utl.inArray(window.CONSTS.MIMIC, typeConsts)) {
          return ['unknown', '？'];
        } else {
          return ['not_mimic', '宝'];
        }
      } else {
        switch (typeConsts[0]) {
          case window.CONSTS.MIMIC:
            return ['mimic', 'ミミック'];
          case window.CONSTS.NOT_MIMIC:
            return ['not_mimic', '宝'];
          case window.CONSTS.EQUIP:
            return ['equip', '装備'];
          case window.CONSTS.MONEY:
            return ['money', 'お金'];
          case window.CONSTS.COMMODITY:
            return ['commodity', '消費アイテム'];
          default:
            return ['', ''];
        }
      }
    })();
    $('.title').eq(index).addClass(className).html(html);
    $('td').eq(index).addClass(className);
  }
  // 狂った宝箱判定
  if (mads !== null) {
    results1 = [];
    for (index = l = 0, len1 = mads.length; l < len1; index = ++l) {
      madArray = mads[index];
      if (madArray.length === 1 && madArray[0]) {
        results1.push($('.title_mad').eq(index).addClass('mimic').html('狂った宝箱'));
      } else {
        results1.push(void 0);
      }
    }
    return results1;
  }
};

// 宝の種別を考慮しないといけないか
mustConsiderType = function(conds) {
  var cond, j, len;
  for (j = 0, len = conds.length; j < len; j++) {
    cond = conds[j];
    if ((732 <= cond && cond <= 744)) {
      return true;
    }
    if ((832 <= cond && cond <= 844)) {
      return true;
    }
    if ((932 <= cond && cond <= 944)) {
      return true;
    }
    if ((1032 <= cond && cond <= 1044)) {
      return true;
    }
    if ((10002 <= cond && cond <= 10014)) {
      return true;
    }
    if ((20002 <= cond && cond <= 20014)) {
      return true;
    }
    if ((30002 <= cond && cond <= 30014)) {
      return true;
    }
    if ((40002 <= cond && cond <= 40014)) {
      return true;
    }
    if ((3002 <= cond && cond <= 5104)) {
      return true;
    }
  }
  return false;
};

checkMimic = function(validPattern, numMimicMin, numMimicMax) {
  var index, j, len, mimic, typeConstArray;
  mimic = 0;
  for (index = j = 0, len = validPattern.length; j < len; index = ++j) {
    typeConstArray = validPattern[index];
    if (typeConstArray.length === 1 && typeConstArray[0] === window.CONSTS.MIMIC) {
      mimic++;
    }
  }
  console.log('checkMimic:', (numMimicMin <= mimic && mimic <= numMimicMax));
  return (numMimicMin <= mimic && mimic <= numMimicMax);
};

getValidPatterns = function(conds, colors, stockedIndexes, patterns, nums, numMad) {
  var j, l, len, len1, madPattern, madPatterns, pattern, res, valids;
  valids = [];
  for (j = 0, len = patterns.length; j < len; j++) {
    pattern = patterns[j];
    // 狂った宝箱がある場合は、狂った宝箱のパターンも全部試す
    if (numMad > 0) {
      madPatterns = getPatternMad(numMad, pattern);
      for (l = 0, len1 = madPatterns.length; l < len1; l++) {
        madPattern = madPatterns[l];
        res = isValidPattern(conds, colors, stockedIndexes, pattern, nums, madPattern);
        if (res) {
          valids.push([pattern, madPattern]);
        }
      }
    } else {
      // 狂った宝箱がないから普通に調べる
      res = isValidPattern(conds, colors, stockedIndexes, pattern, nums);
      if (res) {
        valids.push([pattern, null]);
      }
    }
  }
  return valids;
};

statValidPatterns = function(validPatterns) {
  var collects, index, j, l, len, len1, madPattern, mads, type, valid;
  collects = [];
  mads = [];
  for (j = 0, len = validPatterns.length; j < len; j++) {
    [valid, madPattern] = validPatterns[j];
    for (index = l = 0, len1 = valid.length; l < len1; index = ++l) {
      type = valid[index];
      if (collects[index] == null) {
        collects[index] = [];
      }
      if (mads[index] == null) {
        mads[index] = [];
      }
      if (!Utl.inArray(type, collects[index])) {
        collects[index].push(type);
      }
      // 狂った宝箱の可能性
      if (madPattern !== null && !Utl.inArray(madPattern[index], mads[index])) {
        mads[index].push(madPattern[index]);
      }
    }
  }
  return [collects, mads];
};

downDementionStat = function(stat) {
  var ary, index, j, len;
  for (index = j = 0, len = stat.length; j < len; index = ++j) {
    ary = stat[index];
    if (ary.length === 1) {
      stat[index] = ary[0];
    } else {
      stat[index] = null;
    }
  }
  return ary;
};

isValidPattern = function(conds, colors, stockedIndexes, pattern, nums, madPattern = null) {
  var cond, index, isMad, isMimic, isTurn, j, len, res;
  console.log('conds, pattern, madPattern', conds, pattern, madPattern);
  for (index = j = 0, len = conds.length; j < len; index = ++j) {
    cond = conds[index];
    isMimic = pattern[index] === window.CONSTS.MIMIC;
    isMad = madPattern !== null && madPattern[index];
    isTurn = isMimic || isMad; // 最終的に反転するか
    res = (function() {
      var ref;
      switch (cond) {
        // ある宝箱の隣にミミックがいる
        case 710:
        case 810:
        case 910:
        case 1010:
          return isContainType(pattern, stockedIndexes.NEAR[index][Math.floor(cond / 100) % 6], window.CONSTS.MIMIC, nums);
        // ある宝箱の隣にミミックがいない
        case 720:
        case 820:
        case 920:
        case 1020:
          return isNotContainType(pattern, stockedIndexes.NEAR[index][Math.floor(cond / 100) % 6], window.CONSTS.MIMIC, nums);
        // ある色の宝箱にミミックがいる
        case 10:
        case 110:
        case 210:
          return isContainType(pattern, stockedIndexes.COLOR[Math.floor(cond / 100) + 1], window.CONSTS.MIMIC, nums);
        // ある色の宝箱にミミックがn匹いる
        case 30:
        case 31:
        case 32:
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 130:
        case 131:
        case 132:
        case 133:
        case 134:
        case 135:
        case 136:
        case 137:
        case 138:
        case 139:
        case 230:
        case 231:
        case 232:
        case 233:
        case 234:
        case 235:
        case 236:
        case 237:
        case 238:
        case 239:
          return isContainTypeCount(pattern, stockedIndexes.COLOR[Math.floor(cond / 100) + 1], window.CONSTS.MIMIC, cond % 10, nums);
        // ある色の宝箱にミミックがいない
        case 20:
        case 120:
        case 220:
          return isNotContainType(pattern, stockedIndexes.COLOR[Math.floor(cond / 100) + 1], window.CONSTS.MIMIC, nums);
        // ある色の宝箱に特定のアイテムが入っている
        case 3002:
        case 3003:
        case 3004:
        case 4002:
        case 4003:
        case 4004:
        case 5002:
        case 5003:
        case 5004:
          return isContainType(pattern, stockedIndexes.COLOR[Math.floor(cond / 1000) - 2], cond % 10, nums);
        // ある色の宝箱に特定のアイテムが入っていない
        case 3102:
        case 3103:
        case 3104:
        case 4102:
        case 4103:
        case 4104:
        case 5102:
        case 5103:
        case 5104:
          return isNotContainType(pattern, stockedIndexes.COLOR[Math.floor(cond / 1000) - 2], cond % 10, nums);
        // ある列にミミックがいる
        case 310:
        case 410:
        case 510:
        case 610:
          return isContainType(pattern, stockedIndexes.LINE[Math.floor(cond / 100) - 2], window.CONSTS.MIMIC, nums);
        // ある列にミミックがいない
        case 320:
        case 420:
        case 520:
        case 620:
          return isNotContainType(pattern, stockedIndexes.LINE[Math.floor(cond / 100) - 2], window.CONSTS.MIMIC, nums);
        // ある列に特定のアイテムが入っている
        case 10002:
        case 10003:
        case 10004:
        case 20002:
        case 20003:
        case 20004:
        case 30002:
        case 30003:
        case 30004:
        case 40002:
        case 40003:
        case 40004:
          return isContainType(pattern, stockedIndexes.LINE[Math.floor(cond / 10000)], cond % 10, nums);
        // ある列に特定のアイテムが入っていない
        case 10012:
        case 10013:
        case 10014:
        case 20012:
        case 20013:
        case 20014:
        case 30012:
        case 30013:
        case 30014:
        case 40012:
        case 40013:
        case 40014:
          return isNotContainType(pattern, stockedIndexes.LINE[Math.floor(cond / 10000)], cond % 10, nums);
        // ミミック同士は隣り合った位置に
        // いる
        case 1100:
        case 1101:
          return isMimicNearly(pattern, stockedIndexes.NEAR);
        // いない
        case 1110:
        case 1111:
          return !isMimicNearly(pattern, stockedIndexes.NEAR);
        
        // 上の列と下の列は
        // 上の列の方がミミックが多い
        case 1210:
          return compareIndexes(pattern, stockedIndexes.LINE[window.DIRECTIONS.UP], stockedIndexes.LINE[window.DIRECTIONS.DOWN], -1);
        // 下の列の方がミミックが多い
        case 1220:
          return compareIndexes(pattern, stockedIndexes.LINE[window.DIRECTIONS.UP], stockedIndexes.LINE[window.DIRECTIONS.DOWN], 1);
        // ミミックの数は同じ
        case 1230:
          return compareIndexes(pattern, stockedIndexes.LINE[window.DIRECTIONS.UP], stockedIndexes.LINE[window.DIRECTIONS.DOWN], 0);
        // 左の列と右の列は
        // 左の列の方がミミックが多い
        case 1310:
          return compareIndexes(pattern, stockedIndexes.LINE[window.DIRECTIONS.LEFT], stockedIndexes.LINE[window.DIRECTIONS.RIGHT], -1);
        // 右の列の方がミミックが多い
        case 1320:
          return compareIndexes(pattern, stockedIndexes.LINE[window.DIRECTIONS.LEFT], stockedIndexes.LINE[window.DIRECTIONS.RIGHT], 1);
        // ミミックの数は同じ
        case 1330:
          return compareIndexes(pattern, stockedIndexes.LINE[window.DIRECTIONS.LEFT], stockedIndexes.LINE[window.DIRECTIONS.RIGHT], 0);
        // 赤宝箱と青宝箱は
        // 赤宝箱の方がミミックが多い
        case 1410:
        case 1520:
          return compareIndexes(pattern, stockedIndexes.COLOR[window.COLORS.RED], stockedIndexes.COLOR[window.COLORS.BLUE], -1);
        // 青宝箱の方がミミックが多い
        case 1420:
        case 1510:
          return compareIndexes(pattern, stockedIndexes.COLOR[window.COLORS.RED], stockedIndexes.COLOR[window.COLORS.BLUE], 1);
        // 同じ
        case 1421:
        case 1521:
          return compareIndexes(pattern, stockedIndexes.COLOR[window.COLORS.RED], stockedIndexes.COLOR[window.COLORS.BLUE], 0);
        // 赤宝箱と黒宝箱は
        // 赤宝箱の方がミミックが多い
        case 1430:
        case 1620:
          return compareIndexes(pattern, stockedIndexes.COLOR[window.COLORS.RED], stockedIndexes.COLOR[window.COLORS.BLACK], -1);
        // 黒宝箱の方がミミックが多い
        case 1440:
        case 1610:
          return compareIndexes(pattern, stockedIndexes.COLOR[window.COLORS.RED], stockedIndexes.COLOR[window.COLORS.BLACK], 1);
        // 同じ
        case 1441:
        case 1621:
          return compareIndexes(pattern, stockedIndexes.COLOR[window.COLORS.RED], stockedIndexes.COLOR[window.COLORS.BLACK], 0);
        // 青宝箱と黒宝箱は
        // 青宝箱の方がミミックが多い
        case 1530:
        case 1640:
          return compareIndexes(pattern, stockedIndexes.COLOR[window.COLORS.BLUE], stockedIndexes.COLOR[window.COLORS.BLACK], -1);
        // 黒宝箱の方がミミックが多い
        case 1540:
        case 1630:
          return compareIndexes(pattern, stockedIndexes.COLOR[window.COLORS.BLUE], stockedIndexes.COLOR[window.COLORS.BLACK], 1);
        // 同じ
        case 1541:
        case 1641:
          return compareIndexes(pattern, stockedIndexes.COLOR[window.COLORS.BLUE], stockedIndexes.COLOR[window.COLORS.BLACK], 0);
        // 私はミミックじゃない
        case 1700:
          return isNotContainType(pattern, [index], window.CONSTS.MIMIC, nums);
        // どこかの方向は特定の宝だ
        case 732:
        case 733:
        case 734:
        case 832:
        case 833:
        case 834:
        case 932:
        case 933:
        case 934:
          return isContainType(pattern, stockedIndexes.NEAR[index][Math.floor(cond / 100) - 6], cond % 10, nums);
        // どこかの方向は特定の宝ではない
        case 742:
        case 743:
        case 744:
        case 842:
        case 843:
        case 844:
        case 942:
        case 943:
        case 944:
          return isNotContainType(pattern, stockedIndexes.NEAR[index][Math.floor(cond / 100) - 6], cond % 10, nums);
        // 特定の色の宝箱の
        // どこかにミミックがいる
        case 1811:
        case 1812:
        case 1813:
        case 1814:
        case 1911:
        case 1912:
        case 1913:
        case 1914:
        case 2011:
        case 2012:
        case 2013:
        case 2014:
          return isContainType(pattern, stockedIndexes.COLOR_NEAR[Math.floor(cond / 100) % 17][cond % 10], window.CONSTS.MIMIC, nums);
        case 1821:
        case 1822:
        case 1823:
        case 1824:
        case 1921:
        case 1922:
        case 1923:
        case 1924:
        case 2021:
        case 2022:
        case 2023:
        case 2024:
          return isNotContainType(pattern, stockedIndexes.COLOR_NEAR[Math.floor(cond / 100) % 17][cond % 10], window.CONSTS.MIMIC, nums);
        // ミミックの
        // どこかにどれかの色がある
        case 2111:
        case 2112:
        case 2113:
        case 2114:
        case 2211:
        case 2212:
        case 2213:
        case 2214:
        case 2311:
        case 2312:
        case 2313:
        case 2314:
          return isContainColorNearMimic(pattern, colors, stockedIndexes.NEAR, cond % 10, Math.floor(cond / 100) % 20);
        // この中にミミックはn匹いる
        case 50001:
        case 50002:
        case 50003:
        case 50004:
        case 50005:
        case 50006:
        case 50007:
        case 50008:
        case 50009:
          return isContainTypeCount(pattern, (function() {
            var results1 = [];
            for (var l = 0, ref = pattern.length; 0 <= ref ? l < ref : l > ref; 0 <= ref ? l++ : l--){ results1.push(l); }
            return results1;
          }).apply(this), window.CONSTS.MIMIC, cond % 10, nums);
        default:
          isTurn = false;
          return true;
      }
    })();
    
    // ミミックか狂った宝箱なら反転
    if (isTurn) {
      res = !res;
    }
    console.log('cond, condBool, isMimic, isMad', cond, res, isMimic, isMad);
    if (!res) {
      return false;
    }
  }
  return true;
};

// [win]
// 0 : 同じ
// -1: indexes1が多い
// 1 : indexes2が多い
compareIndexes = function(pattern, indexes1, indexes2, win) {
  var index, j, l, len, len1, mimic1, mimic2;
  mimic1 = mimic2 = 0;
  for (j = 0, len = indexes1.length; j < len; j++) {
    index = indexes1[j];
    if (pattern[index] === window.CONSTS.MIMIC) {
      mimic1++;
    }
  }
  for (l = 0, len1 = indexes2.length; l < len1; l++) {
    index = indexes2[l];
    if (pattern[index] === window.CONSTS.MIMIC) {
      mimic2++;
    }
  }
  // line1が多い
  if (win < 0) {
    return mimic1 > mimic2;
  // line2が多い
  } else if (win > 0) {
    return mimic1 < mimic2;
  } else {
    return mimic1 === mimic2;
  }
};

// ミミック同士は隣あった位置にいるか
isMimicNearly = function(pattern, nearIndexes) {
  var index, index1, index2, indexes, j, key, l, len, mimics, o, ref, ref1, ref2, ref3, typeConst;
  if (getMimicIndexes(pattern).length === 1) {
    // 1体しかいないなら偽
    return false;
  }
  mimics = [];
  for (index = j = 0, len = pattern.length; j < len; index = ++j) {
    typeConst = pattern[index];
    if (typeConst === window.CONSTS.MIMIC) {
      mimics.push(index);
    }
  }
  for (index1 = l = 0, ref = mimics.length; (0 <= ref ? l < ref : l > ref); index1 = 0 <= ref ? ++l : --l) {
    for (index2 = o = ref1 = index1 + 1, ref2 = mimics.length; (ref1 <= ref2 ? o < ref2 : o > ref2); index2 = ref1 <= ref2 ? ++o : --o) {
      ref3 = nearIndexes[mimics[index1]];
      for (key in ref3) {
        indexes = ref3[key];
        if (Utl.inArray(mimics[index2], indexes)) {
          return true;
        }
      }
    }
  }
  return false;
};

// 指定したインデックスに指定したタイプがいるか
isContainType = function(pattern, indexes, typeConst, nums) {
  var index, j, len;
  // 存在しない
  if (Utl.inArray(typeConst, [window.CONSTS.MONEY, window.CONSTS.EQUIP, window.CONSTS.COMMODITY])) {
    if (nums[typeConst] === 0) {
      return false;
    }
  }
  for (j = 0, len = indexes.length; j < len; j++) {
    index = indexes[j];
    if (typeConst === window.CONSTS.NOT_MIMIC && pattern[index] !== window.CONSTS.MIMIC) {
      // ミミック以外を指定で、ミミックではない
      return true;
    }
    if (Utl.inArray(typeConst, [window.CONSTS.MONEY, window.CONSTS.EQUIP, window.CONSTS.COMMODITY]) && pattern[index] === window.CONSTS.NOT_MIMIC) {
      // ミミック以外の特定のアイテムを指定で、ミミックではない
      return true;
    }
    if (typeConst === pattern[index]) {
      // タイプ合致
      return true;
    }
  }
  return false;
};

// 指定したインデックスに指定したタイプがn匹いるか
isContainTypeCount = function(pattern, indexes, typeConst, count, nums) {
  var index, j, len, nowCount;
  // そんなに存在しえない
  if (Utl.inArray(typeConst, [window.CONSTS.MONEY, window.CONSTS.EQUIP, window.CONSTS.COMMODITY])) {
    if (nums[typeConst] < count) {
      return false;
    }
  }
  if (typeConst === window.CONSTS.MIMIC) {
    if (nums[typeConst][1] < count) {
      return false;
    }
  }
  nowCount = 0;
  for (j = 0, len = indexes.length; j < len; j++) {
    index = indexes[j];
    if (typeConst === window.CONSTS.NOT_MIMIC && pattern[index] !== window.CONSTS.MIMIC) {
      nowCount++;
    } else if (typeConst === pattern[index]) {
      nowCount++;
    }
  }
  return count === nowCount;
};

// 指定したインデックスに指定したタイプがいないか
isNotContainType = function(pattern, indexes, typeConst, nums) {
  var index, j, len;
  // 存在しない
  if (Utl.inArray(typeConst, [window.CONSTS.MONEY, window.CONSTS.EQUIP, window.CONSTS.COMMODITY])) {
    if (nums[typeConst] === 0) {
      return true;
    }
  }
  if (typeConst === window.CONSTS.MIMIC) {
    if (nums[typeConst][0] === 0 && nums[typeConst][1] === 0) {
      return true;
    }
  }
  for (j = 0, len = indexes.length; j < len; j++) {
    index = indexes[j];
    if (typeConst === window.CONSTS.NOT_MIMIC && pattern[index] !== window.CONSTS.MIMIC) {
      // ミミック以外が含まれていないのに、ミミック以外が含まれている
      return false;
    }
    if (Utl.inArray(typeConst, [window.CONSTS.MONEY, window.CONSTS.EQUIP, window.CONSTS.COMMODITY]) && pattern[index] === window.CONSTS.NOT_MIMIC) {
      // ミミック以外の特定のアイテムを指定で、ミミックではない
      return false;
    }
    if (typeConst === window.CONSTS.MIMIC && pattern[index] === window.CONSTS.MIMIC) {
      // ミミックが含まれていないのに、ミミックである
      return false;
    }
    if (typeConst === pattern[index]) {
      // タイプ合致
      return false;
    }
  }
  return true;
};

// ミミックの隣接に特定の色があるか
isContainColorNearMimic = function(pattern, colors, nearIndexes, direction, color) {
  var j, len, mimicNearIndex, mimicNearIndexes;
  mimicNearIndexes = getMimicNearIndexes(pattern, nearIndexes, direction);
  for (j = 0, len = mimicNearIndexes.length; j < len; j++) {
    mimicNearIndex = mimicNearIndexes[j];
    if (colors[mimicNearIndex] === color) {
      return true;
    }
  }
  return false;
};

getMimicIndexes = function(pattern) {
  var index, j, len, res, typeConst;
  res = [];
  for (index = j = 0, len = pattern.length; j < len; index = ++j) {
    typeConst = pattern[index];
    if (typeConst === window.CONSTS.MIMIC) {
      res.push(index);
    }
  }
  return res;
};

// ミミックの隣接マスを返す
getMimicNearIndexes = function(pattern, nearIndexes, direction) {
  var index, j, l, len, len1, mimicIndex, mimicIndexes, ref, res;
  res = [];
  mimicIndexes = getMimicIndexes(pattern);
  for (j = 0, len = mimicIndexes.length; j < len; j++) {
    mimicIndex = mimicIndexes[j];
    ref = nearIndexes[mimicIndex][direction];
    for (l = 0, len1 = ref.length; l < len1; l++) {
      index = ref[l];
      if (!Utl.inArray(index, res)) {
        res.push(index);
      }
    }
  }
  return res;
};

// 特定の色の宝箱のインデックス
getColorIndexes = function(colors) {
  var color, index, j, len, name, num, ref, res;
  res = {};
  ref = window.COLORS;
  for (name in ref) {
    num = ref[name];
    res[num] = [];
  }
  for (index = j = 0, len = colors.length; j < len; index = ++j) {
    color = colors[index];
    res[color].push(index);
  }
  return res;
};

// 特定の列のインデックス
getLineIndexes = function(colors, x, y) {
  var dirName, dirNum, index, j, l, o, q, ref, ref1, ref2, ref3, ref4, ref5, res;
  res = {};
  ref = window.DIRECTIONS;
  for (dirName in ref) {
    dirNum = ref[dirName];
    res[dirNum] = [];
  }
  for (index = j = 0, ref1 = x; (0 <= ref1 ? j < ref1 : j > ref1); index = 0 <= ref1 ? ++j : --j) {
    // 上
    res[window.DIRECTIONS.UP].push(index);
  }
  for (index = l = ref2 = x * y - x, ref3 = x * y; (ref2 <= ref3 ? l < ref3 : l > ref3); index = ref2 <= ref3 ? ++l : --l) {
    // 下
    res[window.DIRECTIONS.DOWN].push(index);
  }
  for (index = o = 0, ref4 = y; (0 <= ref4 ? o < ref4 : o > ref4); index = 0 <= ref4 ? ++o : --o) {
    // 左
    res[window.DIRECTIONS.LEFT].push(index * x);
  }
  for (index = q = 0, ref5 = y; (0 <= ref5 ? q < ref5 : q > ref5); index = 0 <= ref5 ? ++q : --q) {
    // 右
    res[window.DIRECTIONS.RIGHT].push((index + 1) * x - 1);
  }
  return res;
};

// 特定の宝箱の隣接のインデックス
getNearIndexes = function(colors, x, y) {
  var color, dirName, dirNum, down, index, j, l, left, len, ref, ref1, res, right, up;
  res = Utl.arrayFill(colors.length, {});
  for (index = j = 0, ref = res.length; (0 <= ref ? j < ref : j > ref); index = 0 <= ref ? ++j : --j) {
    ref1 = window.DIRECTIONS;
    for (dirName in ref1) {
      dirNum = ref1[dirName];
      res[index][dirNum] = [];
    }
  }
  for (index = l = 0, len = colors.length; l < len; index = ++l) {
    color = colors[index];
    // 上
    up = index - x;
    if ((0 <= up && up < x * y)) {
      res[index][window.DIRECTIONS.UP].push(up);
    }
    // 下
    down = index + x;
    if ((0 <= down && down < x * y)) {
      res[index][window.DIRECTIONS.DOWN].push(down);
    }
    // 左
    left = index - 1;
    if ((0 <= left && left < x * y) && Math.floor(index / x) === Math.floor(left / x)) {
      res[index][window.DIRECTIONS.LEFT].push(left);
    }
    // 右
    right = index + 1;
    if ((0 <= right && right < x * y) && Math.floor(index / x) === Math.floor(right / x)) {
      res[index][window.DIRECTIONS.RIGHT].push(right);
    }
  }
  return res;
};

// 特定の色の宝箱の隣接のインデックス
getColorNearIndexes = function(colors, x, y) {
  var color, colorName, colorNum, dirName, dirNum, down, index, j, left, len, ref, ref1, res, right, up;
  res = {};
  ref = window.COLORS;
  for (colorName in ref) {
    colorNum = ref[colorName];
    res[colorNum] = {};
    ref1 = window.DIRECTIONS;
    for (dirName in ref1) {
      dirNum = ref1[dirName];
      res[colorNum][dirNum] = [];
    }
  }
  for (index = j = 0, len = colors.length; j < len; index = ++j) {
    color = colors[index];
    // 上
    up = index - x;
    if ((0 <= up && up < x * y)) {
      res[color][window.DIRECTIONS.UP].push(up);
    }
    // 下
    down = index + x;
    if ((0 <= down && down < x * y)) {
      res[color][window.DIRECTIONS.DOWN].push(down);
    }
    // 左
    left = index - 1;
    if ((0 <= left && left < x * y) && Math.floor(index / x) === Math.floor(left / x)) {
      res[color][window.DIRECTIONS.LEFT].push(left);
    }
    // 右
    right = index + 1;
    if ((0 <= right && right < x * y) && Math.floor(index / x) === Math.floor(right / x)) {
      res[color][window.DIRECTIONS.RIGHT].push(right);
    }
  }
  return res;
};

getX = function() {
  return Number($('#num_x').val());
};

getY = function() {
  return Number($('#num_y').val());
};

getCellNum = function() {
  return getX() * getY();
};

getNumMimicMin = function() {
  return Number($('#num_mimic_min').val());
};

getNumMimicMax = function() {
  return Number($('#num_mimic_max').val());
};

getNumMad = function() {
  return Number($('#num_mad').val());
};

isItemDetail = function() {
  return $('#item_detail_on').prop('checked');
};

getNumMoney = function() {
  return Number($('#num_money').val());
};

getNumEquip = function() {
  return Number($('#num_equip').val());
};

getNumCommodity = function() {
  return Number($('#num_commodity').val());
};

condId2Text = function(condId) {
  var id, jap1, jap2, ref, val;
  ref = window.CONDS;
  for (jap1 in ref) {
    val = ref[jap1];
    for (id in val) {
      jap2 = val[id];
      if (Number(id) === Number(condId)) {
        return jap1 + jap2;
      }
    }
  }
  return null;
};

// 確定パターンの取得
getConfirmTypes = function(modeNotMimic) {
  var confirms;
  confirms = [];
  $('#field tbody').find('select.kind').each(function() {
    var val;
    val = Number($(this).val());
    if (val === 0) {
      return confirms.push(null);
    } else if (modeNotMimic && val !== window.CONSTS.MIMIC) {
      return confirms.push(0);
    } else {
      return confirms.push(val);
    }
  });
  return confirms;
};

genPattern = function(ary, pattern = null) {
  var all, consts, getPatternFunc, j, len, num, remain, total;
  // [ミミック以外(オールマイティ), ミミック, 装備, お金, 消費アイテム]
  consts = [window.CONSTS.NOT_MIMIC, window.CONSTS.MIMIC, window.CONSTS.EQUIP, window.CONSTS.MONEY, window.CONSTS.COMMODITY];
  remain = Utl.clone(ary);
  total = 0;
  for (j = 0, len = ary.length; j < len; j++) {
    num = ary[j];
    total += num;
  }
  all = [];
  getPatternFunc = function(m, remain) {
    var index, l, len1, newM, newRemain, results1;
    if (m.length === total) {
      all.push(m);
      return true;
    }
    results1 = [];
    for (index = l = 0, len1 = remain.length; l < len1; index = ++l) {
      num = remain[index];
      if (num <= 0) {
        continue;
      }
      // 指定のもの以外は飛ばす
      if (pattern !== null) {
        if (pattern[m.length] !== null && pattern[m.length].length > 0 && !Utl.inArray(consts[index], pattern[m.length])) {
          continue;
        }
      }
      newM = Utl.clone(m);
      newRemain = Utl.clone(remain);
      newRemain[index]--;
      newM.push(consts[index]);
      results1.push(getPatternFunc(newM, newRemain));
    }
    return results1;
  };
  getPatternFunc([], remain);
  console.log('genPattern 組み合わせ:', ary, pattern, all);
  return all;
};

getPatternMad = function(numMad, pattern) {
  var all, getPatternFunc;
  if (numMad <= 0) {
    // 狂った宝箱なし
    return null;
  }
  all = [];
  getPatternFunc = function(m, remain) {
    var bool, j, len, newM, newRemain, ref, results1;
    if (m.length === pattern.length) {
      if (remain === 0) {
        all.push(m);
      }
      return true;
    }
    ref = [true, false];
    results1 = [];
    for (j = 0, len = ref.length; j < len; j++) {
      bool = ref[j];
      if (bool && remain <= 0) {
        continue;
      }
      if (bool && pattern[m.length] === window.CONSTS.MIMIC) {
        continue;
      }
      newM = Utl.clone(m);
      newRemain = bool ? remain - 1 : remain;
      newM.push(bool);
      results1.push(getPatternFunc(newM, newRemain));
    }
    return results1;
  };
  getPatternFunc([], numMad);
  console.log('getPatternMad 組み合わせ:', numMad, pattern, all);
  return all;
};

window.Utl = (function() {
  class Utl {
    //###########################################

    // 数値にカンマを入れる

    // @param Number num
    // @return String

    //###########################################
    static numFormat(num) {
      return String(num).replace(/(\d)(?=(\d\d\d)+(?!\d))/g, '$1,');
    }

    //###########################################

    // min <= n <= max の整数乱数を生成

    // @param Number min
    // @param Number max
    // @return String

    //###########################################
    static rand(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    //###########################################

    // length 文字のランダムな文字列を生成

    // @param Number length
    // @return String

    //###########################################
    static genPassword(length = 4) {
      var chars, i, j, ref, res;
      chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
      res = '';
      for (i = j = 0, ref = length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        res += chars.substr(this.rand(0, chars.length - 1), 1);
      }
      return res;
    }

    //###########################################

    // アドレスバーを変更

    // @param String url
    // @return String

    //###########################################
    static adrBar(url) {
      return window.history.replaceState('', '', '' + url);
    }

    //###########################################

    // getクエリを取得

    // @return Object

    //###########################################
    static getQuery(key = null, defaultValue = null) {
      var j, k, len, p, params, query, res, v;
      query = document.location.search.substring(1);
      params = query.split('&');
      res = {};
      for (j = 0, len = params.length; j < len; j++) {
        p = params[j];
        [k, v] = p.split('=');
        res[k] = v;
      }
      if (key === null) {
        return res;
      }
      if (res[key] != null) {
        return res[key];
      }
      return defaultValue;
    }

    //###########################################

    // 数値を min <= num < max の範囲で正規化する

    // @param Number num
    // @param Number min
    // @param Number max
    // @return String

    //###########################################
    static normalize(num, min = 0, max = 1) {
      var range;
      range = Math.abs(max - min);
      if (num < min) {
        num += range * Math.ceil(Math.abs(num - min) / range);
      } else if (max <= num) {
        num -= range * (Math.floor(Math.abs(num - max) / range) + 1);
      }
      return num;
    }

    //###########################################

    // 現在秒を取得

    // @return int

    //###########################################
    static time(date = null) {
      if (date === null) {
        date = new Date();
      }
      return Math.floor(+date / 1000);
    }

    //###########################################

    // 現在ミリ秒を取得

    // @return int/float

    //###########################################
    static militime(date = null, getAsFloat = false) {
      if (date === null) {
        date = new Date();
      }
      return +date / (getAsFloat ? 1000 : 1);
    }

    //###########################################

    // 現在日を YYYY-MM-DD で取得

    // @param Date date
    // @param String dateSep 日付のセパレータ
    // @return String

    //###########################################
    static dateStr(date = null, dateSep = '-') {
      if (date === null) {
        date = new Date();
      }
      return '' + this.zerofill(date.getFullYear(), 4) + dateSep + this.zerofill(date.getMonth() + 1, 2) + dateSep + this.zerofill(date.getDate(), 2);
    }

    //###########################################

    // 現在日時を YYYY-MM-DD HH:ii:ssで取得

    // @param Date date
    // @param String dateSep 日付のセパレータ
    // @param String timeSep 時間のセパレータ
    // @param boolean betweenSep 日付と時間の間の文字
    // @return String

    //###########################################
    static datetimeStr(date = null, dateSep = '-', timeSep = ':', betweenSep = ' ') {
      if (date === null) {
        date = new Date();
      }
      return this.dateStr(date, dateSep) + betweenSep + this.zerofill(date.getHours(), 2) + timeSep + this.zerofill(date.getMinutes(), 2) + timeSep + this.zerofill(date.getSeconds(), 2);
    }

    //###########################################

    // baseDate と targetDate の時刻の差を「何分前」のような表記で取得

    // @param Date targetDate 対象となる日時
    // @param Date baseDate 基準となる日時
    // @param unsigned_int nowSec ついさっき表記する上限の秒数
    // @param String agoStr ついさっき表記の文字列
    // @param String secStr 秒の表記
    // @param String minStr 分の表記
    // @param String hourStr 時間の表記
    // @param String dayStr 日の表記
    // @param String monStr 月の表記
    // @param String yearStr 年の表記
    // @return String

    //###########################################
    static difftime(targetDate, baseDate = null, nowSec = 0, nowStr = 'ついさっき', agoStr = '前', secStr = '秒', minStr = '分', hourStr = '時間', dayStr = '日', monStr = '月', yearStr = '年') {
      var baseTime, d, diffTime, h, m, mo, targetTime, y;
      if (baseDate === null) {
        baseTime = this.time();
      }
      targetTime = this.time(targetDate);
      diffTime = baseTime - targetTime;
      if (diffTime < 0) {
        // 未来
        return null;
      }
      if (nowSec >= diffTime) {
        // ついさっきと表示する基準の秒数
        return nowStr;
      }
      // 一年以上
      y = Math.floor(diffTime / (60 * 60 * 24 * 30 * 12));
      if (y > 0) {
        return '' + y + yearStr + agoStr;
      }
      diffTime -= y * (60 * 60 * 24 * 30 * 12);
      // 一ヶ月以上
      mo = Math.floor(diffTime / (60 * 60 * 24 * 30));
      if (mo > 0) {
        return '' + mo + monStr + agoStr;
      }
      diffTime -= mo * (60 * 60 * 24 * 30);
      // 一日以上
      d = Math.floor(diffTime / (60 * 60 * 24));
      if (d > 0) {
        return '' + d + dayStr + agoStr;
      }
      diffTime -= d * (60 * 60 * 24);
      // 一時間以上
      h = Math.floor(diffTime / (60 * 60));
      if (h > 0) {
        return '' + h + hourStr + agoStr;
      }
      diffTime -= h * (60 * 60);
      // 一分以上
      m = Math.floor(diffTime / 60);
      if (m > 0) {
        return '' + m + minStr + agoStr;
      }
      diffTime -= m * 60;
      if (diffTime > 0) {
        // 一秒以上
        return '' + diffTime + secStr + agoStr;
      }
      // ついさっき
      return nowStr;
    }

    //###########################################

    // 数値をゼロ埋めする

    // @param int num
    // @param int digit 桁数
    // @return int

    //###########################################
    static zerofill(num, digit) {
      return ('' + this.repeat('0', digit) + num).slice(-digit);
    }

    //###########################################

    // str を times 回繰り返した文字列を返す

    // @param String str
    // @param int times
    // @return String

    //###########################################
    static repeat(str, times) {
      return Array(1 + times).join(str);
    }

    //###########################################

    // 配列をシャッフル

    // @param Array ary シャッフルする配列
    // @return Array

    //###########################################
    static shuffle(ary) {
      var i, n;
      n = ary.length;
      while (n) {
        n--;
        i = this.rand(0, n);
        [ary[i], ary[n]] = [ary[n], ary[i]];
      }
      return ary;
    }

    //###########################################

    // 配列 ary に needle が存在するかを調べる

    // @param mixed needle 値
    // @param Array ary
    // @return boolean 存在する場合はtrue, そうでないなら false

    //###########################################
    static inArray(needle, ary) {
      var j, len, v;
      for (j = 0, len = ary.length; j < len; j++) {
        v = ary[j];
        if (v === needle) {
          return true;
        }
      }
      return false;
    }

    //###########################################

    // 配列のコピーを返す

    // @param Array ary
    // @return Array

    //###########################################
    static clone(obj) {
      var res;
      res = obj;
      if ($.isArray(obj)) {
        res = $.extend(true, [], obj);
      } else if (obj instanceof Object) {
        res = $.extend(true, {}, obj);
      }
      return res;
    }

    //###########################################

    // 長さ length の配列を val で満たして返す

    // @param int length
    // @param mixed val
    // @return Array

    //###########################################
    static arrayFill(length, val = null) {
      var i, j, ref, res;
      res = [];
      for (i = j = 0, ref = length; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        res[i] = this.clone(val);
      }
      return res;
    }

    //###########################################

    // x * y の配列を val で満たして返す

    // @param int x
    // @param int y 省略時は x と同じ長さ
    // @param mixed val
    // @return Array

    //###########################################
    static array2dFill(x, y = null, val = null) {
      var j, l, ref, ref1, res, xx, yAry, yy;
      if (y === null) {
        y = x;
      }
      res = [];
      yAry = [];
      for (yy = j = 0, ref = y; (0 <= ref ? j < ref : j > ref); yy = 0 <= ref ? ++j : --j) {
        yAry[yy] = this.clone(val);
      }
      for (xx = l = 0, ref1 = x; (0 <= ref1 ? l < ref1 : l > ref1); xx = 0 <= ref1 ? ++l : --l) {
        res[xx] = this.clone(yAry);
      }
      return res;
    }

    //###########################################

    // 配列の合計を返す

    // @param Array ary
    // @return Array

    //###########################################
    static arraySum(ary) {
      var j, len, sum, v;
      sum = 0;
      for (j = 0, len = ary.length; j < len; j++) {
        v = ary[j];
        sum += v;
      }
      return sum;
    }

    //###########################################

    // 配列の最小値を返す

    // @param Array ary
    // @return Array

    //###########################################
    static arrayMin(ary) {
      var j, len, min, v;
      min = null;
      for (j = 0, len = ary.length; j < len; j++) {
        v = ary[j];
        if (min === null || min > v) {
          min = v;
        }
      }
      return min;
    }

    //###########################################

    // 配列の最大値を返す

    // @param Array ary
    // @return Array

    //###########################################
    static arrayMax(ary) {
      var j, len, max, v;
      max = null;
      for (j = 0, len = ary.length; j < len; j++) {
        v = ary[j];
        if (max === null || max < v) {
          max = v;
        }
      }
      return max;
    }

    //###########################################

    // 連想配列のキーの数を返す

    // @param Object object
    // @return int

    //###########################################
    static count(object) {
      return Object.keys(object).length;
    }

    //###########################################

    // uuid を生成（バージョン4）

    // @return String

    //###########################################
    static uuid4() {
      var i, j, random, uuid;
      uuid = '';
      for (i = j = 0; j < 32; i = ++j) {
        random = Math.random() * 16 | 0;
        if (i === 8 || i === 12 || i === 16 || i === 20) {
          uuid += '-';
        }
        uuid += (i === 12 ? 4 : (i === 16 ? random & 3 | 8 : random)).toString(16);
      }
      return uuid;
    }

    //###########################################

    // ローカルストレージの値を削除

    // @param String key
    // @param mixed value
    // @return undefined

    //###########################################
    static delLs(key) {
      return localStorage.removeItem(key);
    }

    //###########################################

    // ローカルストレージに値を設定

    // @param String key
    // @param mixed value
    // @return undefined

    //###########################################
    static setLs(key, value = null) {
      var json;
      if (value === null) {
        // null は削除
        return this.delLs(key);
      }
      json = JSON.stringify(value);
      return localStorage.setItem(key, json);
    }

    //###########################################

    // ローカルストレージから値を取得

    // @param String key
    // @return undefined

    //###########################################
    static getLs(key) {
      var res;
      res = localStorage.getItem(key);
      try {
        res = JSON.parse(res);
      } catch (error) {
        res = null;
      }
      return res;
    }

    //###########################################

    // ミリ秒待つ（要async/await対応ブラウザ＆coffee2.x）

    // @param String key
    // @return undefined

    //###########################################
    static sleep(msec) {
      return new Promise((resolve, reject) => {
        return setTimeout(() => {
          return resolve();
        }, msec);
      });
    }

  };

  //###########################################

  // key-valueとしてIndexedDBを簡単に使うクラス

  //###########################################
  Utl.IndexedDB = (function() {
    class IndexedDB {
      constructor(dbName = 'default', dbVersion = 1) {
        var open;
        this.dbName = dbName;
        this.dbVersion = dbVersion;
        open = window.indexedDB.open(this.dbName, this.dbVersion);
        open.onupgradeneeded = (evt) => {
          var res;
          res = evt.target.result;
          return res.createObjectStore(this.STORE_NAME, {
            keyPath: 'kvstore_key'
          });
        };
        open.onsuccess = (evt) => {
          return this.db = evt.target.result;
        };
      }

      // awaitで使う
      async set(key, value) {
        var request, store, token, transaction;
        await this.waitUnLock();
        token = this.genToken();
        this.lock(token);
        transaction = this.db.transaction(this.STORE_NAME, 'readwrite');
        store = transaction.objectStore(this.STORE_NAME);
        request = store.put({
          kvstore_key: key,
          kvstore_value: JSON.stringify(value)
        });
        request.onsuccess = (evt) => {
          if (token === this.token) {
            return this.capture(true, token);
          } else {
            return this.capture(false, token);
          }
        };
        request.onerror = (evt) => {
          return this.capture(false, token);
        };
        await this.waitCapture();
        if (token === this.token && this.isCaptured) {
          return this.unlock(token);
        } else {
          return false;
        }
      }

      // awaitで使う
      async get(key) {
        var request, store, token, transaction;
        await this.waitUnLock();
        token = this.genToken();
        this.lock(token);
        transaction = this.db.transaction(this.STORE_NAME, 'readonly');
        store = transaction.objectStore(this.STORE_NAME);
        request = store.get(key);
        request.onsuccess = (evt) => {
          var res;
          try {
            res = JSON.parse(evt.target.result.kvstore_value);
          } catch (error) {
            res = null;
          }
          if (token === this.token) {
            return this.capture(res, token);
          } else {
            return this.unlock(token);
          }
        };
        await this.waitCapture();
        if (this.isCaptured) {
          return this.unlock(token);
        } else {
          return null;
        }
      }

      // awaitで使う
      async gets(keys) {
        var j, key, len, request, res, store, token, transaction;
        await this.waitUnLock();
        token = this.genToken();
        this.lock(token);
        res = {};
        transaction = this.db.transaction(this.STORE_NAME, 'readonly');
        store = transaction.objectStore(this.STORE_NAME);
        for (j = 0, len = keys.length; j < len; j++) {
          key = keys[j];
          request = store.get(key);
          request.onsuccess = (evt) => {
            try {
              return res[evt.target.result.kvstore_key] = JSON.parse(evt.target.result.kvstore_value);
            } catch (error) {
              return res[evt.target.result.kvstore_key] = null;
            }
          };
        }
        transaction.oncomplete = (evt) => {
          return this.capture(res, token);
        };
        await this.waitCapture();
        if (this.isCaptured) {
          return this.unlock(token);
        } else {
          return null;
        }
      }

      // awaitで呼ぶ
      async getAllKeys() {
        var keys, request, store, token, transaction;
        await this.waitUnLock();
        token = this.genToken();
        this.lock(token);
        keys = [];
        transaction = this.db.transaction(this.STORE_NAME, 'readonly');
        store = transaction.objectStore(this.STORE_NAME);
        request = store.openCursor();
        request.onsuccess = (evt) => {
          var cursor;
          cursor = evt.target.result;
          if (cursor) {
            keys.push(cursor.key);
            return cursor.continue();
          } else {
            return this.capture(keys, token);
          }
        };
        request.onerror = (evt) => {
          return this.unlock(token);
        };
        await this.waitCapture();
        if (this.isCaptured) {
          return this.unlock(token);
        } else {
          return [];
        }
      }

      destroy() {
        return window.indexedDB.deleteDatabase(this.dbName);
      }

      unlock(token = null) {
        var res;
        if (token === null || token === this.token) {
          res = this.result;
          this.result = null;
          this.isCaptured = false;
          this.locked = null;
          this.token = null;
          this.isLocked = false;
          return res;
        } else {
          return null;
        }
      }

      capture(value, token) {
        if (this.token === token) {
          this.isLocked = true;
          this.isCaptured = true;
          return this.result = value;
        }
      }

      lock(token) {
        this.isLocked = true;
        this.token = token;
        this.isCaptured = false;
        this.locked = +(new Date());
        this.result = null;
        return true;
      }

      async waitUnLock() {
        while (this.isLocked && +(new Date()) - this.locked < this.TIMEOUT_MSEC) {
          await Utl.sleep(this.LOCK_WAIT_MSEC);
        }
        return true;
      }

      async waitCapture() {
        while (!this.isCaptured && +(new Date()) - this.locked < this.TIMEOUT_MSEC) {
          await Utl.sleep(this.LOCK_WAIT_MSEC);
        }
        return true;
      }

      async waitInitialized() {
        while (this.isInitialized && +(new Date()) - this.locked < this.TIMEOUT_MSEC) {
          await Utl.sleep(this.LOCK_WAIT_MSEC);
        }
        return true;
      }

      genToken() {
        return '' + (+new Date()) + Utl.genPassword(128);
      }

    };

    // テーブル名
    IndexedDB.prototype.STORE_NAME = 'default';

    // ロック待ちミリ秒（1回あたり）
    IndexedDB.prototype.LOCK_WAIT_MSEC = 50;

    // タイムアウトにするミリ秒
    IndexedDB.prototype.TIMEOUT_MSEC = 5000;

    return IndexedDB;

  }).call(this);

  return Utl;

}).call(this);
